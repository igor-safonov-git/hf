<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huntflow Demo Bot</title>
    <style>
        body {
            margin: 0;
            font-family: system-ui, -apple-system, sans-serif;
            background-color: #f9fafb;
            height: 100vh;
        }
        #root {
            height: 100%;
        }
        .container {
            margin: 0;
            padding: 0;
            height: 100%;
            display: flex;
            flex-direction: row;
        }
        .report-panel {
            width: 65%;
            background: white;
            border-right: 1px solid #e5e7eb;
            padding: 2rem;
            overflow-y: auto;
            transition: width 0.3s ease;
            position: relative;
        }
        .report-panel.full-width {
            width: 100%;
            border-right: none;
        }
        .chat-panel {
            width: 35%;
            background: #f9fafb;
            display: flex;
            flex-direction: column;
            padding: 0;
            transition: all 0.3s ease;
        }
        .chat-panel.hidden {
            width: 0;
            overflow: hidden;
            opacity: 0;
        }
        .chat-toggle {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            padding: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            z-index: 10;
            transition: all 0.2s ease;
        }
        .chat-toggle:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }
        .mention-dropdown {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            margin-bottom: 0.5rem;
        }
        .mention-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .mention-item:last-child {
            border-bottom: none;
        }
        .mention-item:hover, .mention-item.selected {
            background: #f3f4f6;
        }
        .mention-item.selected {
            background: #dbeafe;
        }
        .mention-icon {
            font-size: 1.25rem;
        }
        .mention-icon:empty {
            display: none;
        }
        .mention-text {
            flex: 1;
        }
        .mention-name {
            font-weight: 500;
            color: #1f2937;
        }
        .mention-desc {
            font-size: 0.875rem;
            color: #6b7280;
        }
        .mentioned-entity {
            background-color: #dbeafe;
            color: #1e40af;
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-weight: 500;
            display: inline-block;
            margin: 0 0.125rem;
            cursor: pointer;
            border: 1px solid #bfdbfe;
        }
        .mentioned-entity:hover {
            background-color: #bfdbfe;
        }
        .input-container {
            position: relative;
        }
        .title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 1rem;
        }
        .chat-container {
            flex: 1;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            height: 1vh;
        }
        .report-title {
            font-size: 1.75rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 2rem;
            text-align: center;
        }
        .metrics-container {
            display: flex;
            justify-content: space-around;
            margin-bottom: 2rem;
        }
        .metric {
            text-align: center;
        }
        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #3b82f6;
            margin-bottom: 0.5rem;
        }
        .metric-label {
            font-size: 0.875rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .chart-container {
            margin-top: 2rem;
            height: 400px;
        }
        
        /* Table styles */
        .table-wrapper {
            width: 100%;
            overflow-x: auto;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            margin-top: 2rem;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
            background-color: white;
        }
        
        .data-table thead {
            background-color: #f9fafb;
        }
        
        .data-table th {
            padding: 0.75rem 1rem;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
            white-space: nowrap;
        }
        
        .data-table th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 2rem;
        }
        
        .data-table th.sortable:hover {
            background-color: #f3f4f6;
        }
        
        .data-table th.sortable::after {
            content: 'â†•';
            position: absolute;
            right: 0.75rem;
            opacity: 0.5;
        }
        
        .data-table th.sortable.asc::after {
            content: 'â†‘';
            opacity: 1;
        }
        
        .data-table th.sortable.desc::after {
            content: 'â†“';
            opacity: 1;
        }
        
        .data-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .data-table td.numeric {
            text-align: right;
            font-variant-numeric: tabular-nums;
        }
        
        .data-table tbody tr:hover {
            background-color: #f9fafb;
        }
        
        .data-table tbody tr:last-child td {
            border-bottom: none;
        }
        
        /* Mobile responsive */
        @media (max-width: 640px) {
            .data-table {
                font-size: 0.75rem;
            }
            
            .data-table th,
            .data-table td {
                padding: 0.5rem;
            }
        }
        
        /* Grouped Metrics Styles */
        .grouped-metrics {
            margin-bottom: 2rem;
        }
        
        .grouped-metrics h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .metrics-breakdown-table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        
        .metrics-breakdown-table th {
            background-color: #f9fafb;
            padding: 0.75rem 1rem;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
        }
        
        .metrics-breakdown-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: top;
        }
        
        .metrics-breakdown-table td.numeric {
            text-align: right;
            font-variant-numeric: tabular-nums;
            font-weight: 500;
        }
        
        .metrics-breakdown-table tbody tr:hover {
            background-color: #f9fafb;
        }
        
        .metrics-breakdown-table tbody tr:last-child td {
            border-bottom: none;
        }
        
        .metrics-breakdown-table tfoot {
            background-color: #f3f4f6;
            font-weight: 600;
        }
        
        .metrics-breakdown-table tfoot td {
            border-top: 2px solid #d1d5db;
            border-bottom: none;
        }
        
        .grouped-totals {
            display: flex;
            justify-content: space-around;
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f9fafb;
            border-radius: 0.5rem;
        }
        
        .grouped-total {
            text-align: center;
        }
        
        .grouped-total-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1f2937;
        }
        
        .grouped-total-label {
            font-size: 0.875rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
        
        .no-report {
            text-align: center;
            color: #6b7280;
            margin-top: 4rem;
        }
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
        }
        .user-message {
            background-color: #3b82f6;
            color: white;
            margin-left: 2rem;
        }
        .assistant-message {
            background-color: #f3f4f6;
            color: #1f2937;
            margin-right: 2rem;
        }
        .assistant-message img {
            max-width: 100%;
            margin-top: 0.5rem;
        }
        .input-container {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
            border-top: 1px solid #e5e7eb;
        }
        .button-row {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }
        .input {
            width: 100%;
            padding: 0.5rem 1rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 1rem;
            min-height: 80px;
            resize: vertical;
            font-family: inherit;
            box-sizing: border-box;
        }
        .input-wrapper {
            position: relative;
            width: 100%;
        }
        .input-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 0.5rem 1rem;
            border: 1px solid transparent;
            border-radius: 0.375rem;
            font-size: 1rem;
            pointer-events: none;
            color: #374151;
            z-index: 3;
            white-space: pre;
            overflow: hidden;
            background: transparent;
        }
        .button {
            padding: 0.5rem 1rem;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-size: 1rem;
            cursor: pointer;
        }
        .button:hover {
            background-color: #2563eb;
        }
        .button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        .undo-button {
            padding: 0.5rem 1rem;
            background-color: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 1rem;
            cursor: pointer;
        }
        .undo-button:hover {
            background-color: #e5e7eb;
        }
        .undo-button:disabled {
            background-color: #f9fafb;
            color: #9ca3af;
            cursor: not-allowed;
        }
        .mic-button {
            padding: 0.5rem;
            background-color: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 44px;
        }
        .mic-button:hover {
            background-color: #e5e7eb;
        }
        .mic-button.recording {
            background-color: #dc2626;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .welcome {
            text-align: center;
            color: #6b7280;
            padding: 2rem;
        }
        .suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            margin-top: 1rem;
        }
        .suggestion {
            padding: 0.5rem 1rem;
            background-color: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.875rem;
        }
        .suggestion:hover {
            background-color: #e5e7eb;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script>
        const { useState, useEffect, useRef } = React;
        const { createRoot } = ReactDOM;

        function App() {
            const [messages, setMessages] = useState([]);
            const [input, setInput] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [report, setReport] = useState(null);
            const [previousReport, setPreviousReport] = useState(null);
            const [threadId, setThreadId] = useState(null);
            const [selectedModel, setSelectedModel] = useState('deepseek');
            const [temperature, setTemperature] = useState(0.1);
            const [prefetchedData, setPrefetchedData] = useState(null);
            const [isPrefetching, setIsPrefetching] = useState(true);
            const [isRecording, setIsRecording] = useState(false);
            const [speechSupported, setSpeechSupported] = useState(false);
            const [isChatVisible, setIsChatVisible] = useState(true);
            const [showMentions, setShowMentions] = useState(false);
            const [mentionFilter, setMentionFilter] = useState('');
            const [selectedMentionIndex, setSelectedMentionIndex] = useState(0);
            const messagesEndRef = useRef(null);
            const chartRef = useRef(null);
            const chartInstance = useRef(null);
            const mediaRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);

            // Auto-detect API URL based on current protocol (standard ports)
            const apiUrl = window.location.protocol + "//" + window.location.hostname;

            // Entity definitions for mentions
            const entities = [
                { name: 'ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ñ‹', englishName: 'applicants', icon: '', desc: 'ÐšÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ñ‹ Ð¸ ÑÐ¾Ð¸ÑÐºÐ°Ñ‚ÐµÐ»Ð¸' },
                { name: 'Ð²Ð°ÐºÐ°Ð½ÑÐ¸Ð¸', englishName: 'vacancies', icon: '', desc: 'Ð’Ð°ÐºÐ°Ð½ÑÐ¸Ð¸ Ð¸ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸' },
                { name: 'Ð½Ð°Ð¹Ð¼Ñ‹', englishName: 'hires', icon: '', desc: 'ÐŸÑ€Ð¸Ð½ÑÑ‚Ñ‹Ðµ Ð½Ð° Ñ€Ð°Ð±Ð¾Ñ‚Ñƒ' },
                { name: 'Ð¾Ñ‚ÐºÐ°Ð·Ñ‹', englishName: 'rejections', icon: '', desc: 'ÐžÑ‚ÐºÐ°Ð·Ñ‹ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð°Ð¼' },
                { name: 'Ñ€ÐµÐºÑ€ÑƒÑ‚ÐµÑ€Ñ‹', englishName: 'recruiters', icon: '', desc: 'Ð ÐµÐºÑ€ÑƒÑ‚ÐµÑ€Ñ‹ Ð¸ HR' },
                { name: 'Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸', englishName: 'sources', icon: '', desc: 'Ð˜ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²' },
                { name: 'ÑÑ‚Ð°Ð¿Ñ‹', englishName: 'stages', icon: '', desc: 'Ð­Ñ‚Ð°Ð¿Ñ‹ Ð½Ð°Ð¹Ð¼Ð°' },
                { name: 'Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ', englishName: 'actions', icon: '', desc: 'Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ Ñ€ÐµÐºÑ€ÑƒÑ‚ÐµÑ€Ð¾Ð²' },
                { name: 'Ð¾Ñ‚Ð´ÐµÐ»Ñ‹', englishName: 'divisions', icon: '', desc: 'ÐžÑ‚Ð´ÐµÐ»Ñ‹ Ð¸ Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð´ÐµÐ»ÐµÐ½Ð¸Ñ' },
                { name: 'Ñ€ÑƒÐºÐ¾Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»Ð¸', englishName: 'hiring_managers', icon: '', desc: 'Ð ÑƒÐºÐ¾Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»Ð¸ Ð½Ð°Ð¹Ð¼Ð°' }
            ];

            const scrollToBottom = () => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            };

            useEffect(() => {
                scrollToBottom();
            }, [messages]);

            // Initialize audio recording and prefetch data on page load
            useEffect(() => {
                // Check for MediaRecorder support and secure context
                const isSecureContext = window.isSecureContext || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                const hasMediaRecorder = !!window.MediaRecorder;
                
                console.log('Audio recording check:', {
                    isSecureContext,
                    hasMediaRecorder,
                    hostname: window.location.hostname,
                    protocol: window.location.protocol
                });
                
                if (hasMediaRecorder && isSecureContext) {
                    setSpeechSupported(true);
                    console.log('Audio recording supported');
                } else {
                    console.log('Audio recording not supported:', {
                        reason: !hasMediaRecorder ? 'No MediaRecorder API' : 'Not secure context'
                    });
                    setSpeechSupported(false);
                }
                
                const prefetchData = async () => {
                    try {
                        console.log('ðŸ”„ Prefetching Huntflow data...');
                        const response = await fetch(`${apiUrl}/api/prefetch-data`);
                        const data = await response.json();
                        
                        console.log('âœ… Prefetch complete:', data);
                        setPrefetchedData(data);
                        setIsPrefetching(false);
                    } catch (error) {
                        console.error('âŒ Prefetch failed:', error);
                        setIsPrefetching(false);
                    }
                };
                
                prefetchData();
            }, []);

            // No longer generating fake data - using real API data only

            const generateChartData = (reportData) => {
                const chartConfig = reportData.chart;
                let data = {};

                // Use real data only
                const chartDataSource = chartConfig.real_data;
                if (chartDataSource && (chartDataSource.values || chartDataSource.points)) {
                    if (chartConfig.type === 'scatter') {
                        // For scatter plots, handle multiple data formats
                        let scatterData = chartDataSource.points || chartDataSource.values;
                        
                        // Convert array format [[x,y], [x,y]] to object format [{x,y}, {x,y}]
                        if (scatterData && Array.isArray(scatterData) && scatterData.length > 0) {
                            if (Array.isArray(scatterData[0])) {
                                // Format: [[x,y], [x,y]] -> [{x,y}, {x,y}]
                                scatterData = scatterData.map(point => ({
                                    x: point[0],
                                    y: point[1]
                                }));
                            }
                            // If already in {x,y} format, use as-is
                        } else {
                            // Fallback to random data
                            scatterData = Array.from({length: 20}, () => ({
                                x: Math.random() * 100,
                                y: Math.random() * 100
                            }));
                        }
                        
                        data = {
                            datasets: [{
                                label: chartConfig.y_label || chartConfig.y_axis_name || 'Data Points',
                                data: scatterData,
                                backgroundColor: 'rgba(59, 130, 246, 0.8)'
                            }]
                        };
                    } else {
                        // For bar, line, histogram charts - need both labels and values
                        if (chartDataSource.labels && chartDataSource.values) {
                            data = {
                                labels: chartDataSource.labels,
                                datasets: [{
                                    label: chartConfig.y_label || chartConfig.y_axis_name || 'Count',
                                    data: chartDataSource.values,
                                    backgroundColor: chartConfig.type === 'line' ? 'rgba(59, 130, 246, 0.2)' : 'rgba(59, 130, 246, 0.8)',
                                    borderColor: 'rgba(59, 130, 246, 1)',
                                    borderWidth: 1,
                                    tension: chartConfig.type === 'line' ? 0.1 : undefined
                                }]
                            };
                        } else {
                            // Fall back to generated data if labels missing
                            data = null;
                        }
                    }
                }
                
                // If no valid data, show empty chart
                if (!data) {
                    data = {
                        labels: ['No Data'],
                        datasets: [{
                            label: chartConfig.y_label || chartConfig.y_axis_name || 'Count',
                            data: [0],
                            backgroundColor: 'rgba(156, 163, 175, 0.8)',
                            borderColor: 'rgba(156, 163, 175, 1)',
                            borderWidth: 1
                        }]
                    };
                }

                return data;
            };
            
            const renderGroupedMetrics = (reportData) => {
                const mainMetric = reportData.main_metric;
                const secondaryMetrics = reportData.secondary_metrics || [];
                
                // Always render traditional metric cards
                return React.createElement('div', { className: 'metrics-container', key: 'metrics' }, [
                    // Main metric card
                    React.createElement('div', { className: 'metric', key: 'main-metric' }, [
                        React.createElement('div', { className: 'metric-value', key: 'main-value' }, 
                            typeof (mainMetric.total_value || mainMetric.real_value || mainMetric.value || 0) === 'number' ? 
                                (mainMetric.total_value || mainMetric.real_value || mainMetric.value || 0).toLocaleString('ru-RU') : 
                                (mainMetric.total_value || mainMetric.real_value || mainMetric.value || 0)
                        ),
                        React.createElement('div', { className: 'metric-label', key: 'main-label' }, mainMetric.label)
                    ]),
                    // Secondary metric cards
                    ...secondaryMetrics.map((metric, index) => 
                        React.createElement('div', { className: 'metric', key: `secondary-${index}` }, [
                            React.createElement('div', { className: 'metric-value', key: `secondary-value-${index}` }, 
                                typeof (metric.total_value || metric.real_value || metric.value || 0) === 'number' ? 
                                    (metric.total_value || metric.real_value || metric.value || 0).toLocaleString('ru-RU') : 
                                    (metric.total_value || metric.real_value || metric.value || 0)
                            ),
                            React.createElement('div', { className: 'metric-label', key: `secondary-label-${index}` }, metric.label)
                        ])
                    )
                ]);
            };
            
            const renderTable = (tableData, container) => {
                if (!container) {
                    console.error('Container is null in renderTable');
                    return;
                }
                
                // Clear container
                container.innerHTML = '';
                
                // Create wrapper div for responsive scrolling
                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';
                
                // Create table element
                const table = document.createElement('table');
                table.className = 'data-table';
                
                // Generate table header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                tableData.columns.forEach(col => {
                    const th = document.createElement('th');
                    th.textContent = col.label;
                    th.className = col.sortable ? 'sortable' : '';
                    th.dataset.key = col.key;
                    
                    // Add sort indicator class
                    if (tableData.metadata?.sorted_by === col.key) {
                        th.className += ' ' + (tableData.metadata.sort_order || 'desc');
                    }
                    
                    if (col.sortable) {
                        th.addEventListener('click', () => sortTable(col.key, tableData, container));
                    }
                    
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Generate table body
                const tbody = document.createElement('tbody');
                
                tableData.rows.forEach(row => {
                    const tr = document.createElement('tr');
                    
                    tableData.columns.forEach(col => {
                        const td = document.createElement('td');
                        const value = row[col.key];
                        
                        // Format based on column type
                        switch(col.type) {
                            case 'number':
                                td.textContent = value ? value.toLocaleString('ru-RU') : '0';
                                td.className = 'numeric';
                                break;
                            case 'percentage':
                                td.textContent = value ? `${value.toFixed(1)}%` : '0%';
                                td.className = 'numeric';
                                break;
                            default:
                                td.textContent = value || '';
                        }
                        
                        tr.appendChild(td);
                    });
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                wrapper.appendChild(table);
                container.appendChild(wrapper);
            };
            
            const sortTable = (key, tableData, container) => {
                // Toggle sort order
                const currentSort = tableData.metadata?.sorted_by;
                const currentOrder = tableData.metadata?.sort_order || 'desc';
                const newOrder = (currentSort === key && currentOrder === 'desc') ? 'asc' : 'desc';
                
                // Sort rows
                tableData.rows.sort((a, b) => {
                    const aVal = a[key];
                    const bVal = b[key];
                    
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return newOrder === 'desc' ? bVal - aVal : aVal - bVal;
                    }
                    
                    const aStr = String(aVal || '');
                    const bStr = String(bVal || '');
                    return newOrder === 'desc' ? bStr.localeCompare(aStr, 'ru') : aStr.localeCompare(bStr, 'ru');
                });
                
                // Update metadata
                if (!tableData.metadata) tableData.metadata = {};
                tableData.metadata.sorted_by = key;
                tableData.metadata.sort_order = newOrder;
                
                // Re-render table
                renderTable(tableData, container);
            };

            const createChart = (reportData) => {
                if (!chartRef.current || !reportData.chart) return;
                
                // Check if it's a table type
                if (reportData.chart.type === 'table') {
                    // Destroy any existing chart
                    if (chartInstance.current) {
                        chartInstance.current.destroy();
                        chartInstance.current = null;
                    }
                    
                    // Get the chart container (parent of canvas)
                    if (!chartRef.current || !chartRef.current.parentElement) {
                        console.error('Chart container not found');
                        return;
                    }
                    
                    const container = chartRef.current.parentElement;
                    
                    // Render table instead of chart
                    if (reportData.chart.real_data && container) {
                        renderTable(reportData.chart.real_data, container);
                    }
                    return;
                }
                
                // If switching from table to chart, ensure canvas exists
                if (!chartRef.current.getContext) {
                    // Canvas was replaced by table, recreate it
                    const container = chartRef.current.parentElement || chartRef.current;
                    container.innerHTML = '';
                    const canvas = document.createElement('canvas');
                    container.appendChild(canvas);
                    chartRef.current = canvas;
                }
                
                // Regular chart handling
                if (chartInstance.current) {
                    chartInstance.current.destroy();
                }

                const ctx = chartRef.current.getContext('2d');
                const chartData = generateChartData(reportData);
                const chartType = (reportData.chart.type === 'histogram' ? 'bar' : reportData.chart.type) || 'bar';

                chartInstance.current = new Chart(ctx, {
                    type: chartType,
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: reportData.chart.label || reportData.chart.graph_description || 'Chart'
                            },
                            legend: {
                                display: chartType !== 'scatter'
                            }
                        },
                        scales: chartType !== 'scatter' ? {
                            x: {
                                title: {
                                    display: true,
                                    text: reportData.chart.x_label || reportData.chart.x_axis_name || 'X Axis'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: reportData.chart.y_label || reportData.chart.y_axis_name || 'Y Axis'
                                },
                                beginAtZero: true
                            }
                        } : {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: reportData.chart.x_label || reportData.chart.x_axis_name || 'X Axis'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: reportData.chart.y_label || reportData.chart.y_axis_name || 'Y Axis'
                                }
                            }
                        }
                    }
                });
            };

            useEffect(() => {
                if (report) {
                    // Small delay to ensure DOM is ready
                    setTimeout(() => {
                        createChart(report);
                    }, 100);
                }
            }, [report]);

            const handleSend = async () => {
                if (!input.trim() || isLoading) return;

                const userMessage = { role: 'user', content: input };
                setMessages(prev => [...prev, userMessage]);
                setInput('');
                setIsLoading(true);

                try {
                    // Create AbortController for 90-second timeout (LangGraph processing can be slow)
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 90000); // 90 seconds
                    
                    const response = await fetch(`${apiUrl}/chat`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            message: input,
                            thread_id: threadId,
                            model: selectedModel,
                            use_real_data: true,
                            messages: messages,
                            temperature: temperature
                        }),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);

                    const data = await response.json();
                    
                    // Store thread_id for future requests
                    if (data.thread_id && !threadId) {
                        setThreadId(data.thread_id);
                    }
                    
                    // Try to parse JSON response for report generation
                    let conversationalText = data.response;
                    let reportData = null;
                    
                    try {
                        console.log('Trying to parse response:', data.response.substring(0, 200));
                        
                        // Extract JSON from markdown code blocks if present
                        let jsonString = data.response;
                        const jsonMatch = data.response.match(/```json\s*([\s\S]*?)\s*```/);
                        if (jsonMatch) {
                            jsonString = jsonMatch[1];
                            console.log('Extracted JSON from code blocks:', jsonString.substring(0, 100));
                        }
                        
                        const parsedResponse = JSON.parse(jsonString);
                        console.log('Parsed JSON successfully:', parsedResponse);
                        
                        // Check if it's the new conversational format
                        if (parsedResponse.conversational_text && parsedResponse.chart_data) {
                            console.log('New conversational format detected');
                            conversationalText = parsedResponse.conversational_text;
                            reportData = parsedResponse.chart_data;
                        } else if (parsedResponse.report_title && parsedResponse.main_metric && parsedResponse.chart) {
                            // Legacy format - direct report data
                            console.log('Legacy format detected');
                            reportData = parsedResponse;
                        }
                        
                        console.log('Report data:', !!reportData);
                        console.log('Conversational text:', conversationalText.substring(0, 100));
                        
                        if (reportData && reportData.report_title && reportData.main_metric && reportData.chart) {
                            console.log('All conditions met, generating report');
                            // Use real data only - no demo fallbacks
                            const enrichedReport = {
                                ...reportData,
                                main_metric: {
                                    ...reportData.main_metric,
                                    value: reportData.main_metric.real_value ?? 0
                                },
                                secondary_metrics: reportData.secondary_metrics?.map(metric => ({
                                    ...metric,
                                    value: metric.real_value ?? 0
                                })) || []
                            };
                            console.log('Setting report:', enrichedReport);
                            // Save current report as previous before setting new one
                            setPreviousReport(report);
                            setReport(enrichedReport);
                        } else {
                            console.log('Conditions not met for report generation');
                        }
                    } catch (jsonError) {
                        // Not a JSON response, no report to generate
                        console.log('Response is not JSON, skipping report generation. Error:', jsonError);
                    }
                    
                    // Add the conversational message to chat (either parsed text or original response)
                    setMessages(prev => [...prev, { 
                        role: 'assistant', 
                        content: conversationalText 
                    }]);
                } catch (error) {
                    let errorMessage;
                    if (error.name === 'AbortError') {
                        errorMessage = 'â±ï¸ Request timeout after 90 seconds. LangGraph processing took too long. Please try a simpler question or check the server status.';
                    } else if (error.message.includes('fetch')) {
                        errorMessage = 'âš ï¸ Network error. Please check if the backend is running and try again.';
                    } else {
                        errorMessage = `âš ï¸ Error: ${error.message || 'Something went wrong. Please try again.'}`;
                    }
                    
                    setMessages(prev => [...prev, { 
                        role: 'assistant', 
                        content: errorMessage
                    }]);
                } finally {
                    setIsLoading(false);
                }
            };

            const handleSuggestion = (text) => {
                setInput(text);
            };

            const toggleChatPanel = () => {
                setIsChatVisible(!isChatVisible);
            };

            const handleUndo = () => {
                if (messages.length >= 2) {
                    // Remove last two messages (user question and AI response)
                    setMessages(prev => prev.slice(0, -2));
                    // Restore previous report
                    setReport(previousReport);
                    setPreviousReport(null);
                }
            };

            // Handle input changes for mention detection
            const handleInputChange = (e) => {
                const value = e.target.value;
                setInput(value);
                
                // Check for @ mentions
                const cursorPos = e.target.selectionStart;
                const textBeforeCursor = value.slice(0, cursorPos);
                const lastAtIndex = textBeforeCursor.lastIndexOf('@');
                
                if (lastAtIndex !== -1) {
                    const textAfterAt = textBeforeCursor.slice(lastAtIndex + 1);
                    if (!textAfterAt.includes(' ') && !textAfterAt.includes('\n')) {
                        // Still typing after @
                        setMentionFilter(textAfterAt);
                        setShowMentions(true);
                        setSelectedMentionIndex(0);
                        return;
                    }
                }
                
                setShowMentions(false);
            };

            // Handle keyboard navigation in mentions and entity deletion
            const handleKeyDown = (e) => {
                // Handle backspace for entity deletion
                if (e.key === 'Backspace' && !showMentions) {
                    const cursorPos = e.target.selectionStart;
                    const value = input;
                    
                    // Check if cursor is right after a mentioned entity
                    const textBeforeCursor = value.slice(0, cursorPos);
                    const mentionMatch = textBeforeCursor.match(/@([Ð°-ÑÑ‘]+)\s*$/i);
                    
                    if (mentionMatch) {
                        e.preventDefault();
                        // Delete the entire mention including the @
                        const newValue = 
                            value.slice(0, cursorPos - mentionMatch[0].length) + 
                            value.slice(cursorPos);
                        setInput(newValue);
                        
                        // Set cursor position
                        setTimeout(() => {
                            const newCursorPos = cursorPos - mentionMatch[0].length;
                            e.target.setSelectionRange(newCursorPos, newCursorPos);
                        }, 0);
                        return;
                    }
                }
                
                if (!showMentions) return;
                
                const filteredEntities = entities.filter(entity => 
                    entity.name.toLowerCase().includes(mentionFilter.toLowerCase()) ||
                    entity.desc.toLowerCase().includes(mentionFilter.toLowerCase())
                );
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    setSelectedMentionIndex(prev => 
                        prev < filteredEntities.length - 1 ? prev + 1 : 0
                    );
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    setSelectedMentionIndex(prev => 
                        prev > 0 ? prev - 1 : filteredEntities.length - 1
                    );
                } else if (e.key === 'Enter' && filteredEntities.length > 0) {
                    e.preventDefault();
                    insertMention(filteredEntities[selectedMentionIndex]);
                } else if (e.key === 'Escape') {
                    setShowMentions(false);
                }
            };

            // Insert selected mention into input
            const insertMention = (entity) => {
                const inputElement = document.querySelector('textarea.input');
                if (!inputElement) return;
                
                const cursorPos = inputElement.selectionStart;
                const value = input;
                const textBeforeCursor = value.slice(0, cursorPos);
                const textAfterCursor = value.slice(cursorPos);
                const lastAtIndex = textBeforeCursor.lastIndexOf('@');
                
                if (lastAtIndex !== -1) {
                    const entityToInsert = entity.name;  // Use Russian name
                    const newValue = 
                        textBeforeCursor.slice(0, lastAtIndex) + 
                        '@' + entityToInsert + ' ' + 
                        textAfterCursor;
                    setInput(newValue);
                    setShowMentions(false);
                    
                    // Set cursor position after mention
                    setTimeout(() => {
                        const newCursorPos = lastAtIndex + entityToInsert.length + 2;
                        inputElement.setSelectionRange(newCursorPos, newCursorPos);
                        inputElement.focus();
                    }, 0);
                }
            };

            // Render input with highlighted mentions
            const renderInputWithMentions = () => {
                const parts = input.split(/(@[Ð°-ÑÑ‘]+)/gi);
                const entityNames = entities.map(e => e.name);
                
                return React.createElement('div', {
                    className: 'input-overlay',
                    key: 'overlay'
                }, parts.map((part, index) => {
                    if (part.startsWith('@')) {
                        const entityName = part.slice(1);
                        if (entityNames.includes(entityName)) {
                            return React.createElement('span', {
                                key: index,
                                className: 'mentioned-entity'
                            }, part);
                        }
                    }
                    return React.createElement('span', { 
                        key: index
                    }, part);
                }));
            };

            const toggleAudioRecording = async () => {
                if (!speechSupported) {
                    alert('Audio recording not supported. Try using Chrome/Edge on HTTPS or localhost.');
                    return;
                }

                if (isRecording) {
                    console.log('Stopping audio recording...');
                    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
                        mediaRecorderRef.current.stop();
                    }
                } else {
                    console.log('Starting audio recording...');
                    try {
                        // Request microphone access
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            audio: {
                                echoCancellation: true,
                                noiseSuppression: true,
                                autoGainControl: true
                            } 
                        });
                        
                        // Reset audio chunks
                        audioChunksRef.current = [];
                        
                        // Create MediaRecorder with appropriate mime type
                        let mimeType = 'audio/webm';
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = 'audio/wav';
                        }
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = 'audio/ogg';
                        }
                        
                        const mediaRecorder = new MediaRecorder(stream, { mimeType });
                        mediaRecorderRef.current = mediaRecorder;
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunksRef.current.push(event.data);
                            }
                        };
                        
                        mediaRecorder.onstop = async () => {
                            console.log('Audio recording stopped, processing...');
                            setIsRecording(false);
                            
                            // Stop all tracks to release microphone
                            stream.getTracks().forEach(track => track.stop());
                            
                            if (audioChunksRef.current.length > 0) {
                                // Create blob and send to transcription endpoint
                                const audioBlob = new Blob(audioChunksRef.current, { type: mimeType });
                                await transcribeAudio(audioBlob);
                            }
                        };
                        
                        mediaRecorder.start();
                        setIsRecording(true);
                        console.log('Audio recording started');
                        
                    } catch (error) {
                        console.error('Error starting audio recording:', error);
                        if (error.name === 'NotAllowedError') {
                            alert('Microphone access denied. Please allow microphone access to use voice input.');
                        } else if (error.name === 'NotFoundError') {
                            alert('No microphone found. Please check your microphone settings.');
                        } else {
                            alert(`Failed to start voice input: ${error.message}`);
                        }
                        setIsRecording(false);
                    }
                }
            };

            const transcribeAudio = async (audioBlob) => {
                try {
                    console.log('Sending audio for transcription...');
                    const formData = new FormData();
                    formData.append('audio', audioBlob, 'recording.webm');
                    
                    const response = await fetch(`${apiUrl}/transcribe`, {
                        method: 'POST',
                        body: formData,
                    });
                    
                    const result = await response.json();
                    
                    if (result.success && result.text) {
                        console.log('Transcription successful:', result.text);
                        setInput(result.text);
                    } else {
                        console.error('Transcription failed:', result.error);
                        alert(`Transcription failed: ${result.error || 'Unknown error'}`);
                    }
                } catch (error) {
                    console.error('Error during transcription:', error);
                    alert(`Failed to transcribe audio: ${error.message}`);
                }
            };

            const renderMessage = (msg) => {
                // Handle markdown images like ![alt text](data:image/png;base64,...)
                if (msg.content.includes('![') && msg.content.includes('data:image/png;base64,')) {
                    // Split on image markdown pattern
                    const imageRegex = /!\[([^\]]*)\]\((data:image\/png;base64,[^)]+)\)/g;
                    let lastIndex = 0;
                    const elements = [];
                    let match;
                    
                    while ((match = imageRegex.exec(msg.content)) !== null) {
                        // Add text before the image
                        if (match.index > lastIndex) {
                            elements.push(msg.content.substring(lastIndex, match.index));
                        }
                        
                        // Add the image
                        elements.push(React.createElement('img', {
                            src: match[2],
                            alt: match[1] || 'Chart',
                            key: `img-${match.index}`,
                            style: { maxWidth: '100%', height: 'auto', margin: '10px 0' }
                        }));
                        
                        lastIndex = imageRegex.lastIndex;
                    }
                    
                    // Add remaining text after last image
                    if (lastIndex < msg.content.length) {
                        elements.push(msg.content.substring(lastIndex));
                    }
                    
                    return elements.length > 1 ? elements : msg.content;
                }
                
                // Fallback: check for data URI without proper markdown
                if (msg.content.includes('data:image/png;base64,')) {
                    const parts = msg.content.split('data:image/png;base64,');
                    if (parts.length > 1) {
                        const base64Data = parts[1].split(/\s/)[0]; // Get base64 until whitespace
                        return [
                            parts[0],
                            React.createElement('img', { 
                                src: `data:image/png;base64,${base64Data}`, 
                                alt: 'Chart',
                                style: { maxWidth: '100%', height: 'auto', margin: '10px 0' }
                            }),
                            parts[1].substring(base64Data.length)
                        ];
                    }
                }
                
                return msg.content;
            };

            return React.createElement('div', { className: 'container' }, [
                // Report Panel
                React.createElement('div', { 
                    className: `report-panel ${!isChatVisible ? 'full-width' : ''}`, 
                    key: 'report-panel' 
                }, [
                    // Chat toggle button
                    React.createElement('button', {
                        key: 'chat-toggle',
                        className: 'chat-toggle',
                        onClick: toggleChatPanel,
                        title: isChatVisible ? 'Hide chat panel' : 'Show chat panel'
                    }, 'ðŸ’¬'),
                    
                    report ? [
                        React.createElement('h1', { className: 'report-title', key: 'report-title' }, report.report_title),
                        // Always render grouped metrics breakdown table
                        renderGroupedMetrics(report),
                        React.createElement('div', { className: 'chart-container', key: 'chart-container' }, [
                            React.createElement('canvas', { ref: chartRef, key: 'chart' })
                        ])
                    ] : React.createElement('div', { className: 'no-report', key: 'no-report' }, 'Ask a question to generate a report')
                ]),
                // Chat Panel
                React.createElement('div', { 
                    className: `chat-panel ${!isChatVisible ? 'hidden' : ''}`, 
                    key: 'chat-panel' 
                }, [
                    React.createElement('div', { className: 'chat-container', key: 'chat' }, [
                    React.createElement('div', { className: 'messages', key: 'messages' }, [
                        messages.length === 0 && React.createElement('div', { className: 'welcome', key: 'welcome' }, [
                            isPrefetching ? 
                                React.createElement('div', { key: 'loading' }, [
                                    React.createElement('p', { key: 'loading-text' }, 'ðŸ”„ Loading Huntflow data...'),
                                    React.createElement('div', { 
                                        key: 'loading-spinner',
                                        style: { 
                                            animation: 'spin 1s linear infinite',
                                            fontSize: '24px',
                                            margin: '10px 0'
                                        }
                                    }, 'â³')
                                ]) :
                                [
                                    React.createElement('div', { className: 'suggestions', key: 'suggestions' }, [
                                        'ÐšÑ‚Ð¾ Ð½Ð°Ñˆ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ Ñ€ÐµÐºÑ€ÑƒÑ‚ÐµÑ€?',
                                        'ÐšÐ°ÐºÐ¾Ðµ ÑÑ€ÐµÐ´Ð½ÐµÐµ Ð²Ñ€ÐµÐ¼Ñ Ð´Ð¾ Ð½Ð°Ð¹Ð¼Ð°?',
                                        'ÐšÐ°ÐºÐ¸Ðµ Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸ Ð»ÑƒÑ‡ÑˆÐµ?',
                                        'Ð§Ñ‚Ð¾ Ñ‚Ð°Ð¼ Ñ Ð²Ð¾Ñ€Ð¾Ð½ÐºÐ¾Ð¹?'
                                    ].map((text, i) => 
                                        React.createElement('button', {
                                            key: i,
                                            className: 'suggestion',
                                            onClick: () => handleSuggestion(text)
                                        }, text)
                                    ))
                                ]
                        ]),
                        ...messages.map((msg, index) => 
                            React.createElement('div', {
                                key: index,
                                className: `message ${msg.role}-message`
                            }, renderMessage(msg))
                        ),
                        isLoading && React.createElement('div', {
                            key: 'loading',
                            className: 'message assistant-message'
                        }, 'ðŸ¤– Analyzing with LangGraph... (may take up to 90 seconds)'),
                        React.createElement('div', { ref: messagesEndRef, key: 'scroll-anchor' })
                    ]),
                    React.createElement('div', { className: 'input-container', key: 'input-container' }, [
                        // Mention dropdown
                        showMentions && React.createElement('div', { 
                            className: 'mention-dropdown', 
                            key: 'mention-dropdown' 
                        }, 
                            entities.filter(entity => 
                                entity.name.toLowerCase().includes(mentionFilter.toLowerCase()) ||
                                entity.desc.toLowerCase().includes(mentionFilter.toLowerCase())
                            ).map((entity, index) => 
                                React.createElement('div', {
                                    key: entity.name,
                                    className: `mention-item ${index === selectedMentionIndex ? 'selected' : ''}`,
                                    onClick: () => insertMention(entity)
                                }, [
                                    React.createElement('span', { 
                                        className: 'mention-icon', 
                                        key: 'icon' 
                                    }, entity.icon),
                                    React.createElement('div', { 
                                        className: 'mention-text', 
                                        key: 'text' 
                                    }, [
                                        React.createElement('div', { 
                                            className: 'mention-name', 
                                            key: 'name' 
                                        }, entity.name),
                                        React.createElement('div', { 
                                            className: 'mention-desc', 
                                            key: 'desc' 
                                        }, entity.desc)
                                    ])
                                ])
                            )
                        ),
                        
                        // Input container with overlay for highlighted mentions
                        React.createElement('div', {
                            key: 'input-wrapper',
                            className: 'input-wrapper'
                        }, [
                            React.createElement('textarea', {
                                key: 'input',
                                className: 'input',
                                value: input,
                                onChange: handleInputChange,
                                onKeyDown: handleKeyDown,
                                onKeyPress: (e) => {
                                    if (e.key === 'Enter' && !e.shiftKey && !showMentions) {
                                        e.preventDefault();
                                        handleSend();
                                    }
                                },
                                placeholder: '',
                                disabled: isLoading,
                                style: {
                                    background: 'white',
                                    position: 'relative',
                                    zIndex: 2,
                                    color: 'transparent',
                                    caretColor: 'black'
                                }
                            }),
                            renderInputWithMentions()
                        ]),
                        // Button row under the textarea
                        React.createElement('div', {
                            key: 'button-row',
                            className: 'button-row'
                        }, [
                            speechSupported && React.createElement('button', {
                                key: 'mic',
                                className: `mic-button ${isRecording ? 'recording' : ''}`,
                                onClick: toggleAudioRecording,
                                disabled: isLoading,
                                title: isRecording ? 'Stop recording' : 'Start voice input (OpenAI Whisper)'
                            }, isRecording ? 'â¹ï¸' : 'ðŸŽ¤'),
                            React.createElement('button', {
                                key: 'undo',
                                className: 'undo-button',
                                onClick: handleUndo,
                                disabled: isLoading || messages.length < 2,
                                title: 'Undo last question and answer'
                            }, 'â†¶'),
                            React.createElement('button', {
                                key: 'send',
                                className: 'button',
                                onClick: handleSend,
                                disabled: isLoading || !input.trim()
                            }, 'Send')
                        ].filter(Boolean))
                    ])
                ])
                ])
            ]);
        }

        const root = createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>