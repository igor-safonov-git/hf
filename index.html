<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huntflow Demo Bot</title>
    <style>
        body {
            margin: 0;
            font-family: system-ui, -apple-system, sans-serif;
            background-color: #f9fafb;
            height: 100vh;
        }
        #root {
            height: 100%;
        }
        .container {
            margin: 0;
            padding: 0;
            height: 100%;
            display: flex;
            flex-direction: row;
        }
        .report-panel {
            width: 65%;
            background: white;
            border-right: 1px solid #e5e7eb;
            padding: 2rem;
            overflow-y: auto;
        }
        .chat-panel {
            width: 35%;
            background: #f9fafb;
            display: flex;
            flex-direction: column;
            padding: 0;
        }
        .title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 1rem;
        }
        .chat-container {
            flex: 1;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            height: 1vh;
        }
        .report-title {
            font-size: 1.75rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 2rem;
            text-align: center;
        }
        .metrics-container {
            display: flex;
            justify-content: space-around;
            margin-bottom: 2rem;
        }
        .metric {
            text-align: center;
        }
        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #3b82f6;
            margin-bottom: 0.5rem;
        }
        .metric-label {
            font-size: 0.875rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .chart-container {
            margin-top: 2rem;
            height: 400px;
        }
        .no-report {
            text-align: center;
            color: #6b7280;
            margin-top: 4rem;
        }
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
        }
        .user-message {
            background-color: #3b82f6;
            color: white;
            margin-left: 2rem;
        }
        .assistant-message {
            background-color: #f3f4f6;
            color: #1f2937;
            margin-right: 2rem;
        }
        .assistant-message img {
            max-width: 100%;
            margin-top: 0.5rem;
        }
        .input-container {
            display: flex;
            gap: 0.5rem;
            padding: 1rem;
            border-top: 1px solid #e5e7eb;
        }
        .input {
            flex: 1;
            padding: 0.5rem 1rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 1rem;
        }
        .button {
            padding: 0.5rem 1rem;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-size: 1rem;
            cursor: pointer;
        }
        .button:hover {
            background-color: #2563eb;
        }
        .button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        .welcome {
            text-align: center;
            color: #6b7280;
            padding: 2rem;
        }
        .suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            margin-top: 1rem;
        }
        .suggestion {
            padding: 0.5rem 1rem;
            background-color: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.875rem;
        }
        .suggestion:hover {
            background-color: #e5e7eb;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script>
        const { useState, useEffect, useRef } = React;
        const { createRoot } = ReactDOM;

        function App() {
            const [messages, setMessages] = useState([]);
            const [input, setInput] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [report, setReport] = useState(null);
            const [threadId, setThreadId] = useState(null);
            const [selectedModel, setSelectedModel] = useState('deepseek');
            const [temperature, setTemperature] = useState(0.1);
            const [prefetchedData, setPrefetchedData] = useState(null);
            const [isPrefetching, setIsPrefetching] = useState(true);
            const messagesEndRef = useRef(null);
            const chartRef = useRef(null);
            const chartInstance = useRef(null);

            const apiUrl = window.location.protocol + "//" + window.location.hostname + ":8000";

            const scrollToBottom = () => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            };

            useEffect(() => {
                scrollToBottom();
            }, [messages]);

            // Prefetch data on page load
            useEffect(() => {
                const prefetchData = async () => {
                    try {
                        console.log('ðŸ”„ Prefetching Huntflow data...');
                        const response = await fetch(`${apiUrl}/api/prefetch-data`);
                        const data = await response.json();
                        
                        console.log('âœ… Prefetch complete:', data);
                        setPrefetchedData(data);
                        setIsPrefetching(false);
                    } catch (error) {
                        console.error('âŒ Prefetch failed:', error);
                        setIsPrefetching(false);
                    }
                };
                
                prefetchData();
            }, []);

            // No longer generating fake data - using real API data only

            const generateChartData = (reportData) => {
                const chartConfig = reportData.chart;
                let data = {};

                // Use real data only
                const chartDataSource = chartConfig.real_data;
                if (chartDataSource && (chartDataSource.values || chartDataSource.points)) {
                    if (chartConfig.type === 'scatter') {
                        // For scatter plots, handle multiple data formats
                        let scatterData = chartDataSource.points || chartDataSource.values;
                        
                        // Convert array format [[x,y], [x,y]] to object format [{x,y}, {x,y}]
                        if (scatterData && Array.isArray(scatterData) && scatterData.length > 0) {
                            if (Array.isArray(scatterData[0])) {
                                // Format: [[x,y], [x,y]] -> [{x,y}, {x,y}]
                                scatterData = scatterData.map(point => ({
                                    x: point[0],
                                    y: point[1]
                                }));
                            }
                            // If already in {x,y} format, use as-is
                        } else {
                            // Fallback to random data
                            scatterData = Array.from({length: 20}, () => ({
                                x: Math.random() * 100,
                                y: Math.random() * 100
                            }));
                        }
                        
                        data = {
                            datasets: [{
                                label: chartConfig.y_label || chartConfig.y_axis_name || 'Data Points',
                                data: scatterData,
                                backgroundColor: 'rgba(59, 130, 246, 0.8)'
                            }]
                        };
                    } else {
                        // For bar, line, histogram charts - need both labels and values
                        if (chartDataSource.labels && chartDataSource.values) {
                            data = {
                                labels: chartDataSource.labels,
                                datasets: [{
                                    label: chartConfig.y_label || chartConfig.y_axis_name || 'Count',
                                    data: chartDataSource.values,
                                    backgroundColor: chartConfig.type === 'line' ? 'rgba(59, 130, 246, 0.2)' : 'rgba(59, 130, 246, 0.8)',
                                    borderColor: 'rgba(59, 130, 246, 1)',
                                    borderWidth: 1,
                                    tension: chartConfig.type === 'line' ? 0.1 : undefined
                                }]
                            };
                        } else {
                            // Fall back to generated data if labels missing
                            data = null;
                        }
                    }
                }
                
                // If no valid data, show empty chart
                if (!data) {
                    data = {
                        labels: ['No Data'],
                        datasets: [{
                            label: chartConfig.y_label || chartConfig.y_axis_name || 'Count',
                            data: [0],
                            backgroundColor: 'rgba(156, 163, 175, 0.8)',
                            borderColor: 'rgba(156, 163, 175, 1)',
                            borderWidth: 1
                        }]
                    };
                }

                return data;
            };

            const createChart = (reportData) => {
                if (chartInstance.current) {
                    chartInstance.current.destroy();
                }

                if (!chartRef.current || !reportData.chart) return;

                const ctx = chartRef.current.getContext('2d');
                const chartData = generateChartData(reportData);
                const chartType = (reportData.chart.type === 'histogram' ? 'bar' : reportData.chart.type) || 'bar';

                chartInstance.current = new Chart(ctx, {
                    type: chartType,
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: reportData.chart.label || reportData.chart.graph_description || 'Chart'
                            },
                            legend: {
                                display: chartType !== 'scatter'
                            }
                        },
                        scales: chartType !== 'scatter' ? {
                            x: {
                                title: {
                                    display: true,
                                    text: reportData.chart.x_label || reportData.chart.x_axis_name || 'X Axis'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: reportData.chart.y_label || reportData.chart.y_axis_name || 'Y Axis'
                                },
                                beginAtZero: true
                            }
                        } : {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: reportData.chart.x_label || reportData.chart.x_axis_name || 'X Axis'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: reportData.chart.y_label || reportData.chart.y_axis_name || 'Y Axis'
                                }
                            }
                        }
                    }
                });
            };

            useEffect(() => {
                if (report) {
                    createChart(report);
                }
            }, [report]);

            const handleSend = async () => {
                if (!input.trim() || isLoading) return;

                const userMessage = { role: 'user', content: input };
                setMessages(prev => [...prev, userMessage]);
                setInput('');
                setIsLoading(true);

                try {
                    const response = await fetch(`${apiUrl}/chat`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            message: input,
                            thread_id: threadId,
                            model: selectedModel,
                            use_real_data: true,
                            messages: messages,
                            temperature: temperature
                        }),
                    });

                    const data = await response.json();
                    
                    // Store thread_id for future requests
                    if (data.thread_id && !threadId) {
                        setThreadId(data.thread_id);
                    }
                    
                    setMessages(prev => [...prev, { 
                        role: 'assistant', 
                        content: data.response 
                    }]);

                    // Try to parse JSON response for report generation
                    try {
                        console.log('Trying to parse response:', data.response.substring(0, 200));
                        
                        // Extract JSON from markdown code blocks if present
                        let jsonString = data.response;
                        const jsonMatch = data.response.match(/```json\s*([\s\S]*?)\s*```/);
                        if (jsonMatch) {
                            jsonString = jsonMatch[1];
                            console.log('Extracted JSON from code blocks:', jsonString.substring(0, 100));
                        }
                        
                        const reportData = JSON.parse(jsonString);
                        console.log('Parsed JSON successfully:', reportData);
                        console.log('Has report_title:', !!reportData.report_title);
                        console.log('Has main_metric:', !!reportData.main_metric);
                        console.log('Has chart:', !!reportData.chart);
                        
                        if (reportData.report_title && reportData.main_metric && reportData.chart) {
                            console.log('All conditions met, generating report');
                            // Use real data only - no demo fallbacks
                            const enrichedReport = {
                                ...reportData,
                                main_metric: {
                                    ...reportData.main_metric,
                                    value: reportData.main_metric.real_value ?? 0
                                },
                                secondary_metrics: reportData.secondary_metrics?.map(metric => ({
                                    ...metric,
                                    value: metric.real_value ?? 0
                                })) || []
                            };
                            console.log('Setting report:', enrichedReport);
                            setReport(enrichedReport);
                        } else {
                            console.log('Conditions not met for report generation');
                        }
                    } catch (jsonError) {
                        // Not a JSON response, no report to generate
                        console.log('Response is not JSON, skipping report generation. Error:', jsonError);
                    }
                } catch (error) {
                    setMessages(prev => [...prev, { 
                        role: 'assistant', 
                        content: 'âš ï¸ Error connecting to the server. Please check if the backend is running.' 
                    }]);
                } finally {
                    setIsLoading(false);
                }
            };

            const handleSuggestion = (text) => {
                setInput(text);
            };

            const renderMessage = (msg) => {
                // Handle markdown images like ![alt text](data:image/png;base64,...)
                if (msg.content.includes('![') && msg.content.includes('data:image/png;base64,')) {
                    // Split on image markdown pattern
                    const imageRegex = /!\[([^\]]*)\]\((data:image\/png;base64,[^)]+)\)/g;
                    let lastIndex = 0;
                    const elements = [];
                    let match;
                    
                    while ((match = imageRegex.exec(msg.content)) !== null) {
                        // Add text before the image
                        if (match.index > lastIndex) {
                            elements.push(msg.content.substring(lastIndex, match.index));
                        }
                        
                        // Add the image
                        elements.push(React.createElement('img', {
                            src: match[2],
                            alt: match[1] || 'Chart',
                            key: `img-${match.index}`,
                            style: { maxWidth: '100%', height: 'auto', margin: '10px 0' }
                        }));
                        
                        lastIndex = imageRegex.lastIndex;
                    }
                    
                    // Add remaining text after last image
                    if (lastIndex < msg.content.length) {
                        elements.push(msg.content.substring(lastIndex));
                    }
                    
                    return elements.length > 1 ? elements : msg.content;
                }
                
                // Fallback: check for data URI without proper markdown
                if (msg.content.includes('data:image/png;base64,')) {
                    const parts = msg.content.split('data:image/png;base64,');
                    if (parts.length > 1) {
                        const base64Data = parts[1].split(/\s/)[0]; // Get base64 until whitespace
                        return [
                            parts[0],
                            React.createElement('img', { 
                                src: `data:image/png;base64,${base64Data}`, 
                                alt: 'Chart',
                                style: { maxWidth: '100%', height: 'auto', margin: '10px 0' }
                            }),
                            parts[1].substring(base64Data.length)
                        ];
                    }
                }
                
                return msg.content;
            };

            return React.createElement('div', { className: 'container' }, [
                // Report Panel
                React.createElement('div', { className: 'report-panel', key: 'report-panel' }, [
                    report ? [
                        React.createElement('h1', { className: 'report-title', key: 'report-title' }, report.report_title),
                        React.createElement('div', { className: 'metrics-container', key: 'metrics' }, [
                            React.createElement('div', { className: 'metric', key: 'main-metric' }, [
                                React.createElement('div', { className: 'metric-value', key: 'main-value' }, report.main_metric.value),
                                React.createElement('div', { className: 'metric-label', key: 'main-label' }, report.main_metric.label)
                            ]),
                            ...report.secondary_metrics.map((metric, index) => 
                                React.createElement('div', { className: 'metric', key: `secondary-${index}` }, [
                                    React.createElement('div', { className: 'metric-value', key: `secondary-value-${index}` }, metric.value),
                                    React.createElement('div', { className: 'metric-label', key: `secondary-label-${index}` }, metric.label)
                                ])
                            )
                        ]),
                        React.createElement('div', { className: 'chart-container', key: 'chart-container' }, [
                            React.createElement('canvas', { ref: chartRef, key: 'chart' })
                        ])
                    ] : React.createElement('div', { className: 'no-report', key: 'no-report' }, 'Ask a question to generate a report')
                ]),
                // Chat Panel
                React.createElement('div', { className: 'chat-panel', key: 'chat-panel' }, [
                    React.createElement('div', { className: 'chat-container', key: 'chat' }, [
                    React.createElement('div', { className: 'messages', key: 'messages' }, [
                        messages.length === 0 && React.createElement('div', { className: 'welcome', key: 'welcome' }, [
                            isPrefetching ? 
                                React.createElement('div', { key: 'loading' }, [
                                    React.createElement('p', { key: 'loading-text' }, 'ðŸ”„ Loading Huntflow data...'),
                                    React.createElement('div', { 
                                        key: 'loading-spinner',
                                        style: { 
                                            animation: 'spin 1s linear infinite',
                                            fontSize: '24px',
                                            margin: '10px 0'
                                        }
                                    }, 'â³')
                                ]) :
                                prefetchedData ? [
                                    React.createElement('p', { key: 'welcome-text' }, 'Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ! Ð¯ Ð¿Ð¾Ð¼Ð¾Ð³Ñƒ Ð²Ð°Ð¼ Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾Ñ†ÐµÑÑÑ‹ Ð½Ð°Ð¹Ð¼Ð° Ð² Huntflow.'),
                                    React.createElement('div', { className: 'suggestions', key: 'suggestions' }, [
                                        'ÐšÑ‚Ð¾ Ð½Ð°Ñˆ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ Ñ€ÐµÐºÑ€ÑƒÑ‚ÐµÑ€ Ð¿Ð¾ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ñƒ Ð½Ð°Ð¹Ð¼Ð°?',
                                        'ÐŸÐ¾ÐºÐ°Ð¶Ð¸ Ð²Ð¾Ñ€Ð¾Ð½ÐºÑƒ Ð½Ð°Ð¹Ð¼Ð° Ð¿Ð¾ Ð¾Ñ‚Ð´ÐµÐ»Ð°Ð¼',
                                        'ÐšÐ°ÐºÐ¾Ðµ ÑÑ€ÐµÐ´Ð½ÐµÐµ Ð²Ñ€ÐµÐ¼Ñ Ð´Ð¾ Ð½Ð°Ð¹Ð¼Ð°?',
                                        'ÐÐ½Ð°Ð»Ð¸Ð· ÑÑ„Ñ„ÐµÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸ Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¾Ð² ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²',
                                        'Ð¡Ñ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ° Ð¿Ð¾ ÑÑ‚Ð°Ñ‚ÑƒÑÐ°Ð¼ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²',
                                        'ÐšÐ¾Ð½Ð²ÐµÑ€ÑÐ¸Ñ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð² Ð² Ð½Ð°Ð¹Ð¼ Ð¿Ð¾ Ñ€ÐµÐºÑ€ÑƒÑ‚ÐµÑ€Ð°Ð¼'
                                    ].map((text, i) => 
                                        React.createElement('button', {
                                            key: i,
                                            className: 'suggestion',
                                            onClick: () => handleSuggestion(text)
                                        }, text)
                                    ))
                                ] : [
                                    React.createElement('p', { key: 'welcome-text' }, 'Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ! Ð¯ Ð¿Ð¾Ð¼Ð¾Ð³Ñƒ Ð²Ð°Ð¼ Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾Ñ†ÐµÑÑÑ‹ Ð½Ð°Ð¹Ð¼Ð° Ð² Huntflow.'),
                                    React.createElement('div', { className: 'suggestions', key: 'suggestions' }, [
                                        'ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð²Ð¾Ñ€Ð¾Ð½ÐºÑƒ Ð½Ð°Ð¹Ð¼Ð° IT-ÑÐ¿ÐµÑ†Ð¸Ð°Ð»Ð¸ÑÑ‚Ð¾Ð²',
                                        'ÐÐ½Ð°Ð»Ð¸Ð· Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸ Ñ€ÐµÐºÑ€ÑƒÑ‚ÐµÑ€Ð¾Ð²',
                                        'Ð Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð² Ð¿Ð¾ Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ°Ð¼',
                                        'Ð”Ð¸Ð½Ð°Ð¼Ð¸ÐºÐ° Ð½Ð°Ð¹Ð¼Ð° Ð·Ð° Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ 6 Ð¼ÐµÑÑÑ†ÐµÐ²'
                                    ].map((text, i) => 
                                        React.createElement('button', {
                                            key: i,
                                            className: 'suggestion',
                                            onClick: () => handleSuggestion(text)
                                        }, text)
                                    ))
                                ]
                        ]),
                        ...messages.map((msg, index) => 
                            React.createElement('div', {
                                key: index,
                                className: `message ${msg.role}-message`
                            }, renderMessage(msg))
                        ),
                        isLoading && React.createElement('div', {
                            key: 'loading',
                            className: 'message assistant-message'
                        }, 'Thinking...'),
                        React.createElement('div', { ref: messagesEndRef, key: 'scroll-anchor' })
                    ]),
                    React.createElement('div', { className: 'input-container', key: 'input-container' }, [
                        React.createElement('input', {
                            key: 'input',
                            type: 'text',
                            className: 'input',
                            value: input,
                            onChange: (e) => setInput(e.target.value),
                            onKeyPress: (e) => e.key === 'Enter' && handleSend(),
                            placeholder: 'Ask about Huntflow data...',
                            disabled: isLoading
                        }),
                        React.createElement('button', {
                            key: 'send',
                            className: 'button',
                            onClick: handleSend,
                            disabled: isLoading || !input.trim()
                        }, 'Send')
                    ])
                ])
                ])
            ]);
        }

        const root = createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>