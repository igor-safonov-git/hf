<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huntflow Demo Bot</title>
    <style>
        body {
            margin: 0;
            font-family: system-ui, -apple-system, sans-serif;
            background-color: #f9fafb;
            height: 100vh;
        }
        #root {
            height: 100%;
        }
        .container {
            margin: 0;
            padding: 0;
            height: 100%;
            display: flex;
            flex-direction: row;
        }
        .report-panel {
            width: 65%;
            background: white;
            border-right: 1px solid #e5e7eb;
            padding: 2rem;
            overflow-y: auto;
            transition: width 0.3s ease;
            position: relative;
        }
        .report-panel.full-width {
            width: 100%;
            border-right: none;
        }
        .chat-panel {
            width: 35%;
            background: #f9fafb;
            display: flex;
            flex-direction: column;
            padding: 0;
            transition: all 0.3s ease;
        }
        .chat-panel.hidden {
            width: 0;
            overflow: hidden;
            opacity: 0;
        }
        .chat-toggle {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            padding: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            z-index: 10;
            transition: all 0.2s ease;
        }
        .chat-toggle:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }
        .chat-toggle.chat-hidden {
            background: #3b82f6;
            border-color: #2563eb;
            color: white;
        }
        .chat-toggle.chat-hidden:hover {
            background: #2563eb;
        }
        .title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 1rem;
        }
        .chat-container {
            flex: 1;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            height: 1vh;
        }
        .report-title {
            font-size: 1.75rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 2rem;
            text-align: center;
        }
        .metrics-container {
            display: flex;
            justify-content: space-around;
            margin-bottom: 2rem;
        }
        .metric {
            text-align: center;
        }
        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #3b82f6;
            margin-bottom: 0.5rem;
        }
        .metric-label {
            font-size: 0.875rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .chart-container {
            margin-top: 2rem;
            height: 400px;
        }
        
        /* Table styles */
        .table-wrapper {
            width: 100%;
            overflow-x: auto;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            margin-top: 2rem;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
            background-color: white;
        }
        
        .data-table thead {
            background-color: #f9fafb;
        }
        
        .data-table th {
            padding: 0.75rem 1rem;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
            white-space: nowrap;
        }
        
        .data-table th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 2rem;
        }
        
        .data-table th.sortable:hover {
            background-color: #f3f4f6;
        }
        
        .data-table th.sortable::after {
            content: '↕';
            position: absolute;
            right: 0.75rem;
            opacity: 0.5;
        }
        
        .data-table th.sortable.asc::after {
            content: '↑';
            opacity: 1;
        }
        
        .data-table th.sortable.desc::after {
            content: '↓';
            opacity: 1;
        }
        
        .data-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .data-table td.numeric {
            text-align: right;
            font-variant-numeric: tabular-nums;
        }
        
        .data-table tbody tr:hover {
            background-color: #f9fafb;
        }
        
        .data-table tbody tr:last-child td {
            border-bottom: none;
        }
        
        /* Mobile responsive */
        @media (max-width: 640px) {
            .data-table {
                font-size: 0.75rem;
            }
            
            .data-table th,
            .data-table td {
                padding: 0.5rem;
            }
        }
        
        /* Grouped Metrics Styles */
        .grouped-metrics {
            margin-bottom: 2rem;
        }
        
        .grouped-metrics h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .metrics-breakdown-table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        
        .metrics-breakdown-table th {
            background-color: #f9fafb;
            padding: 0.75rem 1rem;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
        }
        
        .metrics-breakdown-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: top;
        }
        
        .metrics-breakdown-table td.numeric {
            text-align: right;
            font-variant-numeric: tabular-nums;
            font-weight: 500;
        }
        
        .metrics-breakdown-table tbody tr:hover {
            background-color: #f9fafb;
        }
        
        .metrics-breakdown-table tbody tr:last-child td {
            border-bottom: none;
        }
        
        .metrics-breakdown-table tfoot {
            background-color: #f3f4f6;
            font-weight: 600;
        }
        
        .metrics-breakdown-table tfoot td {
            border-top: 2px solid #d1d5db;
            border-bottom: none;
        }
        
        .grouped-totals {
            display: flex;
            justify-content: space-around;
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f9fafb;
            border-radius: 0.5rem;
        }
        
        .grouped-total {
            text-align: center;
        }
        
        .grouped-total-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1f2937;
        }
        
        .grouped-total-label {
            font-size: 0.875rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
        
        .no-report {
            text-align: center;
            color: #6b7280;
            margin-top: 4rem;
        }
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
        }
        .user-message {
            background-color: #3b82f6;
            color: white;
            margin-left: 2rem;
        }
        .assistant-message {
            background-color: #f3f4f6;
            color: #1f2937;
            margin-right: 2rem;
        }
        .assistant-message img {
            max-width: 100%;
            margin-top: 0.5rem;
        }
        .input-container {
            display: flex;
            gap: 0.5rem;
            padding: 1rem;
            border-top: 1px solid #e5e7eb;
        }
        .input {
            flex: 1;
            padding: 0.5rem 1rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 1rem;
        }
        .button {
            padding: 0.5rem 1rem;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-size: 1rem;
            cursor: pointer;
        }
        .button:hover {
            background-color: #2563eb;
        }
        .button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        .mic-button {
            padding: 0.5rem;
            background-color: #6b7280;
            color: white;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 44px;
        }
        .mic-button:hover {
            background-color: #4b5563;
        }
        .mic-button.recording {
            background-color: #dc2626;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .welcome {
            text-align: center;
            color: #6b7280;
            padding: 2rem;
        }
        .suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            margin-top: 1rem;
        }
        .suggestion {
            padding: 0.5rem 1rem;
            background-color: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.875rem;
        }
        .suggestion:hover {
            background-color: #e5e7eb;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script>
        const { useState, useEffect, useRef } = React;
        const { createRoot } = ReactDOM;

        function App() {
            const [messages, setMessages] = useState([]);
            const [input, setInput] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [report, setReport] = useState(null);
            const [threadId, setThreadId] = useState(null);
            const [selectedModel, setSelectedModel] = useState('deepseek');
            const [temperature, setTemperature] = useState(0.1);
            const [prefetchedData, setPrefetchedData] = useState(null);
            const [isPrefetching, setIsPrefetching] = useState(true);
            const [isRecording, setIsRecording] = useState(false);
            const [speechSupported, setSpeechSupported] = useState(false);
            const [isChatVisible, setIsChatVisible] = useState(true);
            const messagesEndRef = useRef(null);
            const chartRef = useRef(null);
            const chartInstance = useRef(null);
            const mediaRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);

            // Auto-detect API URL based on current protocol
            const isHttps = window.location.protocol === 'https:';
            const apiPort = isHttps ? '8443' : '8000';
            const apiUrl = window.location.protocol + "//" + window.location.hostname + ":" + apiPort;

            const scrollToBottom = () => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            };

            useEffect(() => {
                scrollToBottom();
            }, [messages]);

            // Initialize audio recording and prefetch data on page load
            useEffect(() => {
                // Check for MediaRecorder support and secure context
                const isSecureContext = window.isSecureContext || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                const hasMediaRecorder = !!window.MediaRecorder;
                
                console.log('Audio recording check:', {
                    isSecureContext,
                    hasMediaRecorder,
                    hostname: window.location.hostname,
                    protocol: window.location.protocol
                });
                
                if (hasMediaRecorder && isSecureContext) {
                    setSpeechSupported(true);
                    console.log('Audio recording supported');
                } else {
                    console.log('Audio recording not supported:', {
                        reason: !hasMediaRecorder ? 'No MediaRecorder API' : 'Not secure context'
                    });
                    setSpeechSupported(false);
                }
                
                const prefetchData = async () => {
                    try {
                        console.log('🔄 Prefetching Huntflow data...');
                        const response = await fetch(`${apiUrl}/api/prefetch-data`);
                        const data = await response.json();
                        
                        console.log('✅ Prefetch complete:', data);
                        setPrefetchedData(data);
                        setIsPrefetching(false);
                    } catch (error) {
                        console.error('❌ Prefetch failed:', error);
                        setIsPrefetching(false);
                    }
                };
                
                prefetchData();
            }, []);

            // No longer generating fake data - using real API data only

            const generateChartData = (reportData) => {
                const chartConfig = reportData.chart;
                let data = {};

                // Use real data only
                const chartDataSource = chartConfig.real_data;
                if (chartDataSource && (chartDataSource.values || chartDataSource.points)) {
                    if (chartConfig.type === 'scatter') {
                        // For scatter plots, handle multiple data formats
                        let scatterData = chartDataSource.points || chartDataSource.values;
                        
                        // Convert array format [[x,y], [x,y]] to object format [{x,y}, {x,y}]
                        if (scatterData && Array.isArray(scatterData) && scatterData.length > 0) {
                            if (Array.isArray(scatterData[0])) {
                                // Format: [[x,y], [x,y]] -> [{x,y}, {x,y}]
                                scatterData = scatterData.map(point => ({
                                    x: point[0],
                                    y: point[1]
                                }));
                            }
                            // If already in {x,y} format, use as-is
                        } else {
                            // Fallback to random data
                            scatterData = Array.from({length: 20}, () => ({
                                x: Math.random() * 100,
                                y: Math.random() * 100
                            }));
                        }
                        
                        data = {
                            datasets: [{
                                label: chartConfig.y_label || chartConfig.y_axis_name || 'Data Points',
                                data: scatterData,
                                backgroundColor: 'rgba(59, 130, 246, 0.8)'
                            }]
                        };
                    } else {
                        // For bar, line, histogram charts - need both labels and values
                        if (chartDataSource.labels && chartDataSource.values) {
                            data = {
                                labels: chartDataSource.labels,
                                datasets: [{
                                    label: chartConfig.y_label || chartConfig.y_axis_name || 'Count',
                                    data: chartDataSource.values,
                                    backgroundColor: chartConfig.type === 'line' ? 'rgba(59, 130, 246, 0.2)' : 'rgba(59, 130, 246, 0.8)',
                                    borderColor: 'rgba(59, 130, 246, 1)',
                                    borderWidth: 1,
                                    tension: chartConfig.type === 'line' ? 0.1 : undefined
                                }]
                            };
                        } else {
                            // Fall back to generated data if labels missing
                            data = null;
                        }
                    }
                }
                
                // If no valid data, show empty chart
                if (!data) {
                    data = {
                        labels: ['No Data'],
                        datasets: [{
                            label: chartConfig.y_label || chartConfig.y_axis_name || 'Count',
                            data: [0],
                            backgroundColor: 'rgba(156, 163, 175, 0.8)',
                            borderColor: 'rgba(156, 163, 175, 1)',
                            borderWidth: 1
                        }]
                    };
                }

                return data;
            };
            
            const renderGroupedMetrics = (reportData) => {
                const mainMetric = reportData.main_metric;
                const secondaryMetrics = reportData.secondary_metrics || [];
                
                // Always render traditional metric cards
                return React.createElement('div', { className: 'metrics-container', key: 'metrics' }, [
                    // Main metric card
                    React.createElement('div', { className: 'metric', key: 'main-metric' }, [
                        React.createElement('div', { className: 'metric-value', key: 'main-value' }, 
                            typeof (mainMetric.total_value || mainMetric.real_value || mainMetric.value || 0) === 'number' ? 
                                (mainMetric.total_value || mainMetric.real_value || mainMetric.value || 0).toLocaleString('ru-RU') : 
                                (mainMetric.total_value || mainMetric.real_value || mainMetric.value || 0)
                        ),
                        React.createElement('div', { className: 'metric-label', key: 'main-label' }, mainMetric.label)
                    ]),
                    // Secondary metric cards
                    ...secondaryMetrics.map((metric, index) => 
                        React.createElement('div', { className: 'metric', key: `secondary-${index}` }, [
                            React.createElement('div', { className: 'metric-value', key: `secondary-value-${index}` }, 
                                typeof (metric.total_value || metric.real_value || metric.value || 0) === 'number' ? 
                                    (metric.total_value || metric.real_value || metric.value || 0).toLocaleString('ru-RU') : 
                                    (metric.total_value || metric.real_value || metric.value || 0)
                            ),
                            React.createElement('div', { className: 'metric-label', key: `secondary-label-${index}` }, metric.label)
                        ])
                    )
                ]);
            };
            
            const renderTable = (tableData, container) => {
                if (!container) {
                    console.error('Container is null in renderTable');
                    return;
                }
                
                // Clear container
                container.innerHTML = '';
                
                // Create wrapper div for responsive scrolling
                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';
                
                // Create table element
                const table = document.createElement('table');
                table.className = 'data-table';
                
                // Generate table header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                tableData.columns.forEach(col => {
                    const th = document.createElement('th');
                    th.textContent = col.label;
                    th.className = col.sortable ? 'sortable' : '';
                    th.dataset.key = col.key;
                    
                    // Add sort indicator class
                    if (tableData.metadata?.sorted_by === col.key) {
                        th.className += ' ' + (tableData.metadata.sort_order || 'desc');
                    }
                    
                    if (col.sortable) {
                        th.addEventListener('click', () => sortTable(col.key, tableData, container));
                    }
                    
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Generate table body
                const tbody = document.createElement('tbody');
                
                tableData.rows.forEach(row => {
                    const tr = document.createElement('tr');
                    
                    tableData.columns.forEach(col => {
                        const td = document.createElement('td');
                        const value = row[col.key];
                        
                        // Format based on column type
                        switch(col.type) {
                            case 'number':
                                td.textContent = value ? value.toLocaleString('ru-RU') : '0';
                                td.className = 'numeric';
                                break;
                            case 'percentage':
                                td.textContent = value ? `${value.toFixed(1)}%` : '0%';
                                td.className = 'numeric';
                                break;
                            default:
                                td.textContent = value || '';
                        }
                        
                        tr.appendChild(td);
                    });
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                wrapper.appendChild(table);
                container.appendChild(wrapper);
            };
            
            const sortTable = (key, tableData, container) => {
                // Toggle sort order
                const currentSort = tableData.metadata?.sorted_by;
                const currentOrder = tableData.metadata?.sort_order || 'desc';
                const newOrder = (currentSort === key && currentOrder === 'desc') ? 'asc' : 'desc';
                
                // Sort rows
                tableData.rows.sort((a, b) => {
                    const aVal = a[key];
                    const bVal = b[key];
                    
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return newOrder === 'desc' ? bVal - aVal : aVal - bVal;
                    }
                    
                    const aStr = String(aVal || '');
                    const bStr = String(bVal || '');
                    return newOrder === 'desc' ? bStr.localeCompare(aStr, 'ru') : aStr.localeCompare(bStr, 'ru');
                });
                
                // Update metadata
                if (!tableData.metadata) tableData.metadata = {};
                tableData.metadata.sorted_by = key;
                tableData.metadata.sort_order = newOrder;
                
                // Re-render table
                renderTable(tableData, container);
            };

            const createChart = (reportData) => {
                if (!chartRef.current || !reportData.chart) return;
                
                // Check if it's a table type
                if (reportData.chart.type === 'table') {
                    // Destroy any existing chart
                    if (chartInstance.current) {
                        chartInstance.current.destroy();
                        chartInstance.current = null;
                    }
                    
                    // Get the chart container (parent of canvas)
                    if (!chartRef.current || !chartRef.current.parentElement) {
                        console.error('Chart container not found');
                        return;
                    }
                    
                    const container = chartRef.current.parentElement;
                    
                    // Render table instead of chart
                    if (reportData.chart.real_data && container) {
                        renderTable(reportData.chart.real_data, container);
                    }
                    return;
                }
                
                // If switching from table to chart, ensure canvas exists
                if (!chartRef.current.getContext) {
                    // Canvas was replaced by table, recreate it
                    const container = chartRef.current.parentElement || chartRef.current;
                    container.innerHTML = '';
                    const canvas = document.createElement('canvas');
                    container.appendChild(canvas);
                    chartRef.current = canvas;
                }
                
                // Regular chart handling
                if (chartInstance.current) {
                    chartInstance.current.destroy();
                }

                const ctx = chartRef.current.getContext('2d');
                const chartData = generateChartData(reportData);
                const chartType = (reportData.chart.type === 'histogram' ? 'bar' : reportData.chart.type) || 'bar';

                chartInstance.current = new Chart(ctx, {
                    type: chartType,
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: reportData.chart.label || reportData.chart.graph_description || 'Chart'
                            },
                            legend: {
                                display: chartType !== 'scatter'
                            }
                        },
                        scales: chartType !== 'scatter' ? {
                            x: {
                                title: {
                                    display: true,
                                    text: reportData.chart.x_label || reportData.chart.x_axis_name || 'X Axis'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: reportData.chart.y_label || reportData.chart.y_axis_name || 'Y Axis'
                                },
                                beginAtZero: true
                            }
                        } : {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: reportData.chart.x_label || reportData.chart.x_axis_name || 'X Axis'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: reportData.chart.y_label || reportData.chart.y_axis_name || 'Y Axis'
                                }
                            }
                        }
                    }
                });
            };

            useEffect(() => {
                if (report) {
                    // Small delay to ensure DOM is ready
                    setTimeout(() => {
                        createChart(report);
                    }, 100);
                }
            }, [report]);

            const handleSend = async () => {
                if (!input.trim() || isLoading) return;

                const userMessage = { role: 'user', content: input };
                setMessages(prev => [...prev, userMessage]);
                setInput('');
                setIsLoading(true);

                try {
                    const response = await fetch(`${apiUrl}/chat`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            message: input,
                            thread_id: threadId,
                            model: selectedModel,
                            use_real_data: true,
                            messages: messages,
                            temperature: temperature
                        }),
                    });

                    const data = await response.json();
                    
                    // Store thread_id for future requests
                    if (data.thread_id && !threadId) {
                        setThreadId(data.thread_id);
                    }
                    
                    setMessages(prev => [...prev, { 
                        role: 'assistant', 
                        content: data.response 
                    }]);

                    // Try to parse JSON response for report generation
                    try {
                        console.log('Trying to parse response:', data.response.substring(0, 200));
                        
                        // Extract JSON from markdown code blocks if present
                        let jsonString = data.response;
                        const jsonMatch = data.response.match(/```json\s*([\s\S]*?)\s*```/);
                        if (jsonMatch) {
                            jsonString = jsonMatch[1];
                            console.log('Extracted JSON from code blocks:', jsonString.substring(0, 100));
                        }
                        
                        const reportData = JSON.parse(jsonString);
                        console.log('Parsed JSON successfully:', reportData);
                        console.log('Has report_title:', !!reportData.report_title);
                        console.log('Has main_metric:', !!reportData.main_metric);
                        console.log('Has chart:', !!reportData.chart);
                        
                        if (reportData.report_title && reportData.main_metric && reportData.chart) {
                            console.log('All conditions met, generating report');
                            // Use real data only - no demo fallbacks
                            const enrichedReport = {
                                ...reportData,
                                main_metric: {
                                    ...reportData.main_metric,
                                    value: reportData.main_metric.real_value ?? 0
                                },
                                secondary_metrics: reportData.secondary_metrics?.map(metric => ({
                                    ...metric,
                                    value: metric.real_value ?? 0
                                })) || []
                            };
                            console.log('Setting report:', enrichedReport);
                            setReport(enrichedReport);
                        } else {
                            console.log('Conditions not met for report generation');
                        }
                    } catch (jsonError) {
                        // Not a JSON response, no report to generate
                        console.log('Response is not JSON, skipping report generation. Error:', jsonError);
                    }
                } catch (error) {
                    setMessages(prev => [...prev, { 
                        role: 'assistant', 
                        content: '⚠️ Error connecting to the server. Please check if the backend is running.' 
                    }]);
                } finally {
                    setIsLoading(false);
                }
            };

            const handleSuggestion = (text) => {
                setInput(text);
            };

            const toggleChatPanel = () => {
                setIsChatVisible(!isChatVisible);
            };

            const toggleAudioRecording = async () => {
                if (!speechSupported) {
                    alert('Audio recording not supported. Try using Chrome/Edge on HTTPS or localhost.');
                    return;
                }

                if (isRecording) {
                    console.log('Stopping audio recording...');
                    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
                        mediaRecorderRef.current.stop();
                    }
                } else {
                    console.log('Starting audio recording...');
                    try {
                        // Request microphone access
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            audio: {
                                echoCancellation: true,
                                noiseSuppression: true,
                                autoGainControl: true
                            } 
                        });
                        
                        // Reset audio chunks
                        audioChunksRef.current = [];
                        
                        // Create MediaRecorder with appropriate mime type
                        let mimeType = 'audio/webm';
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = 'audio/wav';
                        }
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = 'audio/ogg';
                        }
                        
                        const mediaRecorder = new MediaRecorder(stream, { mimeType });
                        mediaRecorderRef.current = mediaRecorder;
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunksRef.current.push(event.data);
                            }
                        };
                        
                        mediaRecorder.onstop = async () => {
                            console.log('Audio recording stopped, processing...');
                            setIsRecording(false);
                            
                            // Stop all tracks to release microphone
                            stream.getTracks().forEach(track => track.stop());
                            
                            if (audioChunksRef.current.length > 0) {
                                // Create blob and send to transcription endpoint
                                const audioBlob = new Blob(audioChunksRef.current, { type: mimeType });
                                await transcribeAudio(audioBlob);
                            }
                        };
                        
                        mediaRecorder.start();
                        setIsRecording(true);
                        console.log('Audio recording started');
                        
                    } catch (error) {
                        console.error('Error starting audio recording:', error);
                        if (error.name === 'NotAllowedError') {
                            alert('Microphone access denied. Please allow microphone access to use voice input.');
                        } else if (error.name === 'NotFoundError') {
                            alert('No microphone found. Please check your microphone settings.');
                        } else {
                            alert(`Failed to start voice input: ${error.message}`);
                        }
                        setIsRecording(false);
                    }
                }
            };

            const transcribeAudio = async (audioBlob) => {
                try {
                    console.log('Sending audio for transcription...');
                    const formData = new FormData();
                    formData.append('audio', audioBlob, 'recording.webm');
                    
                    const response = await fetch(`${apiUrl}/transcribe`, {
                        method: 'POST',
                        body: formData,
                    });
                    
                    const result = await response.json();
                    
                    if (result.success && result.text) {
                        console.log('Transcription successful:', result.text);
                        setInput(result.text);
                    } else {
                        console.error('Transcription failed:', result.error);
                        alert(`Transcription failed: ${result.error || 'Unknown error'}`);
                    }
                } catch (error) {
                    console.error('Error during transcription:', error);
                    alert(`Failed to transcribe audio: ${error.message}`);
                }
            };

            const renderMessage = (msg) => {
                // Handle markdown images like ![alt text](data:image/png;base64,...)
                if (msg.content.includes('![') && msg.content.includes('data:image/png;base64,')) {
                    // Split on image markdown pattern
                    const imageRegex = /!\[([^\]]*)\]\((data:image\/png;base64,[^)]+)\)/g;
                    let lastIndex = 0;
                    const elements = [];
                    let match;
                    
                    while ((match = imageRegex.exec(msg.content)) !== null) {
                        // Add text before the image
                        if (match.index > lastIndex) {
                            elements.push(msg.content.substring(lastIndex, match.index));
                        }
                        
                        // Add the image
                        elements.push(React.createElement('img', {
                            src: match[2],
                            alt: match[1] || 'Chart',
                            key: `img-${match.index}`,
                            style: { maxWidth: '100%', height: 'auto', margin: '10px 0' }
                        }));
                        
                        lastIndex = imageRegex.lastIndex;
                    }
                    
                    // Add remaining text after last image
                    if (lastIndex < msg.content.length) {
                        elements.push(msg.content.substring(lastIndex));
                    }
                    
                    return elements.length > 1 ? elements : msg.content;
                }
                
                // Fallback: check for data URI without proper markdown
                if (msg.content.includes('data:image/png;base64,')) {
                    const parts = msg.content.split('data:image/png;base64,');
                    if (parts.length > 1) {
                        const base64Data = parts[1].split(/\s/)[0]; // Get base64 until whitespace
                        return [
                            parts[0],
                            React.createElement('img', { 
                                src: `data:image/png;base64,${base64Data}`, 
                                alt: 'Chart',
                                style: { maxWidth: '100%', height: 'auto', margin: '10px 0' }
                            }),
                            parts[1].substring(base64Data.length)
                        ];
                    }
                }
                
                return msg.content;
            };

            return React.createElement('div', { className: 'container' }, [
                // Report Panel
                React.createElement('div', { 
                    className: `report-panel ${!isChatVisible ? 'full-width' : ''}`, 
                    key: 'report-panel' 
                }, [
                    // Chat toggle button
                    React.createElement('button', {
                        key: 'chat-toggle',
                        className: `chat-toggle ${!isChatVisible ? 'chat-hidden' : ''}`,
                        onClick: toggleChatPanel,
                        title: isChatVisible ? 'Hide chat panel' : 'Show chat panel'
                    }, isChatVisible ? '💬' : '📊'),
                    
                    report ? [
                        React.createElement('h1', { className: 'report-title', key: 'report-title' }, report.report_title),
                        // Always render grouped metrics breakdown table
                        renderGroupedMetrics(report),
                        React.createElement('div', { className: 'chart-container', key: 'chart-container' }, [
                            React.createElement('canvas', { ref: chartRef, key: 'chart' })
                        ])
                    ] : React.createElement('div', { className: 'no-report', key: 'no-report' }, 'Ask a question to generate a report')
                ]),
                // Chat Panel
                React.createElement('div', { 
                    className: `chat-panel ${!isChatVisible ? 'hidden' : ''}`, 
                    key: 'chat-panel' 
                }, [
                    React.createElement('div', { className: 'chat-container', key: 'chat' }, [
                    React.createElement('div', { className: 'messages', key: 'messages' }, [
                        messages.length === 0 && React.createElement('div', { className: 'welcome', key: 'welcome' }, [
                            isPrefetching ? 
                                React.createElement('div', { key: 'loading' }, [
                                    React.createElement('p', { key: 'loading-text' }, '🔄 Loading Huntflow data...'),
                                    React.createElement('div', { 
                                        key: 'loading-spinner',
                                        style: { 
                                            animation: 'spin 1s linear infinite',
                                            fontSize: '24px',
                                            margin: '10px 0'
                                        }
                                    }, '⏳')
                                ]) :
                                [
                                    React.createElement('p', { key: 'welcome-text' }, 'Добро пожаловать! Я помогу вам анализировать процессы найма в Huntflow.'),
                                    React.createElement('div', { className: 'suggestions', key: 'suggestions' }, [
                                        'Кто наш лучший рекрутер?',
                                        'Какое среднее время до найма?',
                                        'Какие источники лучше?',
                                        'Что там с воронкой?'
                                    ].map((text, i) => 
                                        React.createElement('button', {
                                            key: i,
                                            className: 'suggestion',
                                            onClick: () => handleSuggestion(text)
                                        }, text)
                                    ))
                                ]
                        ]),
                        ...messages.map((msg, index) => 
                            React.createElement('div', {
                                key: index,
                                className: `message ${msg.role}-message`
                            }, renderMessage(msg))
                        ),
                        isLoading && React.createElement('div', {
                            key: 'loading',
                            className: 'message assistant-message'
                        }, 'Thinking...'),
                        React.createElement('div', { ref: messagesEndRef, key: 'scroll-anchor' })
                    ]),
                    React.createElement('div', { className: 'input-container', key: 'input-container' }, [
                        React.createElement('input', {
                            key: 'input',
                            type: 'text',
                            className: 'input',
                            value: input,
                            onChange: (e) => setInput(e.target.value),
                            onKeyPress: (e) => e.key === 'Enter' && handleSend(),
                            placeholder: speechSupported ? 'Ask about Huntflow data... (🎤 voice or type)' : 'Ask about Huntflow data...',
                            disabled: isLoading
                        }),
                        speechSupported && React.createElement('button', {
                            key: 'mic',
                            className: `mic-button ${isRecording ? 'recording' : ''}`,
                            onClick: toggleAudioRecording,
                            disabled: isLoading,
                            title: isRecording ? 'Stop recording' : 'Start voice input (OpenAI Whisper)'
                        }, isRecording ? '⏹️' : '🎤'),
                        React.createElement('button', {
                            key: 'send',
                            className: 'button',
                            onClick: handleSend,
                            disabled: isLoading || !input.trim()
                        }, 'Send')
                    ])
                ])
                ])
            ]);
        }

        const root = createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>