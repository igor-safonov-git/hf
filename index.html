<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huntflow Демо Бот</title>
    <!-- Marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Inter font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --spacing: 0.25rem;
            --container-xs: 20rem;
            --container-sm: 24rem;
            --container-md: 28rem;
            --container-lg: 32rem;
            --container-xl: 36rem;
            --container-2xl: 42rem;
            --container-3xl: 48rem;
            --container-4xl: 56rem;
            --container-5xl: 64rem;
            --container-6xl: 72rem;
            --text-xs: 0.75rem;
            --text-xs--line-height: 1.33333;
            --text-sm: 0.875rem;
            --text-sm--line-height: 1.42857;
            --text-base: 1rem;
            --text-base--line-height: 1.5;
            --text-lg: 1.125rem;
            --text-lg--line-height: 1.55556;
            --text-xl: 1.25rem;
            --text-xl--line-height: 1.4;
            --text-2xl: 1.5rem;
            --text-2xl--line-height: 1.33333;
            --text-3xl: 1.875rem;
            --text-3xl--line-height: 1.2;
            --text-4xl: 2.25rem;
            --text-4xl--line-height: 1.11111;
            --text-5xl: 3rem;
            --text-5xl--line-height: 1;
            --text-6xl: 3.75rem;
            --text-6xl--line-height: 1;
            --text-7xl: 4.5rem;
            --text-7xl--line-height: 1;
            --font-weight-extralight: 200;
            --font-weight-light: 300;
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            --font-weight-bold: 700;
            --font-weight-extrabold: 800;
            --font-weight-black: 900;
            --tracking-tighter: -0.05em;
            --tracking-tight: -0.025em;
            --tracking-normal: 0em;
            --tracking-wide: 0.025em;
            --tracking-widest: 0.1em;
            --leading-tight: 1.25;
            --leading-snug: 1.375;
            --leading-normal: 1.5;
            --leading-relaxed: 1.625;
            --radius-xs: 0.125rem;
            --radius-sm: 0.25rem;
            --radius-md: 0.375rem;
            --radius-lg: 0.5rem;
            --radius-xl: 0.75rem;
            --radius-2xl: 1rem;
            --radius-3xl: 1.5rem;
            --drop-shadow-xs: 0 1px 1px #0000000d;
            --drop-shadow-md: 0 3px 3px #0000001f;
            --drop-shadow-lg: 0 4px 4px #00000026;
            --ease-in: cubic-bezier(0.4, 0, 1, 1);
            --ease-out: cubic-bezier(0, 0, 0.2, 1);
            --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
            --animate-spin: spin 1s linear infinite;
            --animate-pulse: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            --animate-bounce: bounce 1s infinite;
            --blur-xs: 4px;
            --blur-sm: 8px;
            --blur-md: 12px;
            --blur-lg: 16px;
            --blur-xl: 24px;
            --blur-2xl: 40px;
            --blur-3xl: 64px;
            --aspect-video: 16/9;
            --default-transition-duration: 0.15s;
            --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            --text-heading-2: 1.5rem;
            --text-heading-2--line-height: 1.75rem;
            --text-heading-2--letter-spacing: -0.015625rem;
            --text-heading-2--font-weight: 600;
            --text-heading-3: 1.125rem;
            --text-heading-3--line-height: 1.625rem;
            --text-heading-3--letter-spacing: -0.028125rem;
            --text-heading-3--font-weight: 600;
            --text-body-small-regular: 0.875rem;
            --text-body-small-regular--line-height: 1.125rem;
            --text-body-small-regular--letter-spacing: -0.01875rem;
            --text-body-small-regular--font-weight: 400;
            --text-caption-regular: 0.75rem;
            --text-caption-regular--line-height: 1rem;
            --text-caption-regular--letter-spacing: -0.00625rem;
            --text-caption-regular--font-weight: 400;
            --user-chat-width: 70%;
            --white: #fff;
            --black: #000;
            --gray-50: #f9f9f9;
            --gray-100: #ececec;
            --gray-200: #e3e3e3;
            --gray-300: #cdcdcd;
            --gray-400: #b4b4b4;
            --gray-500: #9b9b9b;
            --gray-600: #676767;
            --gray-700: #424242;
            --gray-750: #2f2f2f;
            --gray-800: #212121;
            --gray-900: #171717;
            --gray-950: #0d0d0d;
            --red-500: #e02e2a;
            --red-700: #911e1b;
            --brand-purple: #ab68ff;
            --yellow-900: #4d3b00;
            --message-surface: #e9e9e980;
            --text-primary: #0d0d0d;
            --text-secondary: #5d5d5d;
            --text-tertiary: #8f8f8f;
            --text-inverted: #fff;
            --text-accent: #66b5ff;
            --text-error: #e02e2a;
            --bg-primary: #fff;
            --bg-secondary: #e8e8e8;
            --bg-tertiary: #f3f3f3;
            --border-default: #0d0d0d1a;
            --border-heavy: #0d0d0d26;
            --border-light: #0d0d0d0d;
            --border-xlight: #0000000d;
            --border-medium: #00000026;
            --border-xheavy: #00000040;
            --border-sharp: #0000000d;
            --interactive-border-focus: #0d0d0d;
            --interactive-border-secondary-default: #0d0d0d1a;
            --interactive-bg-tertiary-default: #fff;
            --interactive-bg-tertiary-hover: #f9f9f9;
            --shadow-color-1: #0000000a;
            --shadow-color-2: #0000009e;
            --breakpoint-md: 48rem;
            --breakpoint-lg: 64rem;
            --breakpoint-xl: 80rem;
            --breakpoint-2xl: 96rem;
            --main-surface-background: #fffffff2;
            --composer-surface: var(--message-surface);
            --composer-blue-bg: #daeeff;
            --composer-blue-hover: #bddcf4;
            --composer-blue-hover-tint: #0084ff24;
            --composer-surface-primary: var(--main-surface-primary);
            --dot-color: var(--black);
            --icon-surface: 13 13 13;
            --text-primary-inverse: var(--gray-100);
            --content-primary: #01172b;
            --content-secondary: #44505b;
            --text-quaternary: var(--gray-300);
            --text-placeholder: #000000b3;
            --tag-blue: #08f;
            --tag-blue-light: #0af;
            --surface-error: 249 58 55;
            --hint-text: #08f;
            --hint-bg: #b3dbff;
            --main-surface-primary: var(--white);
            --main-surface-primary-inverse: var(--gray-800);
            --main-surface-secondary: var(--gray-50);
            --main-surface-secondary-selected: #0000001a;
            --main-surface-tertiary: var(--gray-100);
            --sidebar-width: 260px;
            --sidebar-section-margin-top: 1.25rem;
            --sidebar-section-first-margin-top: 0.5rem;
            --sidebar-rail-width: calc(var(--spacing) * 13);
            --header-height: calc(var(--spacing) * 13);
            --sidebar-surface-primary: var(--gray-50);
            --sidebar-surface-secondary: var(--gray-100);
            --sidebar-surface-tertiary: var(--gray-200);
            --sidebar-title-primary: #28282880;
            --sidebar-surface: #fcfcfc;
            --sidebar-body-primary: #0d0d0d;
            --sidebar-icon: #7d7d7d;
            --surface-hover: #00000012;
            --link: #2964aa;
            --link-hover: #749ac8;
            --selection: #007aff;
            --sidebar-surface-floating-lightness: 1;
            --sidebar-surface-floating-alpha: 1;
            --sidebar-surface-pinned-lightness: 0.99;
            --sidebar-surface-pinned-alpha: 1;
            --cqh-full: 100cqh;
            --cqw-full: 100cqw;
            --spring-fast-duration: 667ms;
            --spring-common-duration: 667ms;
            --spring-standard: var(--spring-common);
            --spring-slow-bounce-duration: 1167ms;
            --spring-bounce-duration: 833ms;
            --spring-fast-bounce-duration: 1s;
            --composer-footer_height: var(--composer-bar_footer-current-height, 32px);
            --composer-bar_height: var(--composer-bar_current-height, 52px);
            --composer-bar_width: var(--composer-bar_current-width, 768px);
            --mask-fill: linear-gradient(180deg, #fff 0%, #fff);
            --mask-erase: linear-gradient(180deg, #000 0%, #000);
            --thread-content-margin: calc(var(--spacing) * 6);
            --thread-content-max-width: 40rem;
            --utility-scrollbar: #0000000a;
            --sharp-edge-top-shadow: 0 1px 0 var(--border-sharp);
            --sharp-edge-top-shadow-placeholder: 0 1px 0 transparent;
            --sharp-edge-bottom-shadow: 0 -1px 0 var(--border-sharp);
            --sharp-edge-bottom-shadow-placeholder: 0 -1px 0 transparent;
            --tw-inset-shadow-alpha: 100%;
            --tw-inset-ring-shadow: 0 0 #0000;
            --tw-inset-shadow: 0 0 #0000;
            --tw-shadow-alpha: 100%;
            --tw-ring-shadow: 0 0 #0000;
            --tw-drop-shadow-alpha: 100%;
            --tw-ring-offset-shadow: 0 0 #0000;
            --tw-shadow: 0 0 #0000;
        }
        
        /* Animations for report elements */
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        html {
            height: 100%;
        }
        body {
            margin: 0;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: #f9fafb;
            height: 100vh;
        }
        h1 {
            margin: 0;
            padding: 0 0 1rem 0;
            letter-spacing: -0.025rem;
            font-size: 2.2rem;
        }
        #root {
            height: 100%;
        }
        .header {
            height: 60px;
            width: 100%;
            background-color: #000;
            position: sticky;
            top: 0;
            left: 0;
            z-index: 1000;
        }
        .container {
            margin: 0;
            padding: 0;
            height: calc(100vh - 60px);
            display: flex;
            flex-direction: row;
        }
        .report-panel {
            width: 65%;
            background: white;
            border-right: 1px solid #e5e7eb;
            padding: 3rem 5rem;
            overflow-y: auto;
            transition: width 0.3s ease;
            position: relative;
        }
        .report-panel.full-width {
            width: 100%;
            border-right: none;
        }
        .chat-panel {
            width: 35%;
            height: 100%;
            background: #f9fafb;
            display: flex;
            flex-direction: column;
            padding: 0;
            transition: all 0.3s ease;
            box-shadow: 0px 4px 4px 0px var(--shadow-color-1), 0px 0px 1px 0px var(--shadow-color-2);
        }
        .chat-panel.hidden {
            width: 0;
            overflow: hidden;
            opacity: 0;
        }
        .chat-toggle {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            padding: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            z-index: 10;
            transition: all 0.2s ease;
        }
        .chat-toggle:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }
        .mention-dropdown {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            margin-bottom: 0.5rem;
        }
        .mention-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .mention-item:last-child {
            border-bottom: none;
        }
        .mention-item:hover, .mention-item.selected {
            background: #f3f4f6;
        }
        .mention-item.selected {
            background: #dbeafe;
        }
        .mention-icon {
            font-size: 1.25rem;
        }
        .mention-icon:empty {
            display: none;
        }
        .mention-text {
            flex: 1;
        }
        .mention-name {
            font-weight: 500;
            color: #1f2937;
        }
        .mention-desc {
            font-size: 0.875rem;
            color: #6b7280;
        }
        .mentioned-entity {
            background-color: #dbeafe;
            color: #1e40af;
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-weight: 500;
            display: inline-block;
            margin: 0 0.125rem;
            cursor: pointer;
            border: 1px solid #bfdbfe;
        }
        .mentioned-entity:hover {
            background-color: #bfdbfe;
        }
        .input-container {
            position: relative;
        }
        .title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 1rem;
        }
        .chat-container {
            flex: 1;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .report-title {
            font-size: 2.2rem;
            font-weight: bold;
            color: #1f2937;
            margin: 0;
            text-align: left;
            padding: 0 0 1rem 0;
            letter-spacing: -0.025rem;
            opacity: 0;
            transform: translateY(30px);
            animation: slideInUp 0.4s ease-out forwards;
        }
        .metrics-container {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            padding: 1.5em 0 0 0;
        }
        .metric {
            text-align: left;
            background-color: #f8f9fa;
            border-radius: 0.5rem;
            padding: 1.5rem;
            width: 33%;
            opacity: 0;
            transform: translateY(20px);
            animation: slideInUp 0.3s ease-out forwards;
        }
        
        .metric:nth-child(1) {
            animation-delay: 0.1s;
        }
        
        .metric:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .metric:nth-child(3) {
            animation-delay: 0.3s;
        }
        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #222;
            margin-bottom: 0.5rem;
        }
        .metric-label {
            font-size: 1rem;
            color: #222;
            font-weight: 500;
            text-transform: none;
        }
        .chart-filters {
            margin-top: 0;
            margin-bottom: 1rem;
            padding: 0px 0 0 0;
            background: none;
            border-radius: 0;
            border: 0;
        }
        
        .filters-grid {
            display: flex;
            gap: 0.5rem;
        }
        
        .filter-item {
            display: inline-block;
        }
        
        .filter-item.active {
            background: #222;
            color: #f1f1f1;
        }
        
        .filter-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: #6b7280;
            margin-bottom: 0.25rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .filter-value {
            padding: 0.3rem 0.5rem 0.2rem 0.5rem;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            color: #374151;
            min-height: 1.25rem;
        }
        
        .filter-value.empty {
            color: #9ca3af;
            font-style: normal;
        }
        
        .chart-container {
            margin-top: 1rem;
            height: 400px;
            padding: 1.5em 0 0 0;
        }
        
        /* Table styles */
        .table-wrapper {
            width: 100%;
            overflow-x: auto;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            margin-top: 2rem;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
            background-color: white;
        }
        
        .data-table thead {
            background-color: #f9fafb;
        }
        
        .data-table th {
            padding: 0.75rem 1rem;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
            white-space: nowrap;
        }
        
        .data-table th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 2rem;
        }
        
        .data-table th.sortable:hover {
            background-color: #f3f4f6;
        }
        
        .data-table th.sortable::after {
            content: '↕';
            position: absolute;
            right: 0.75rem;
            opacity: 0.5;
        }
        
        .data-table th.sortable.asc::after {
            content: '↑';
            opacity: 1;
        }
        
        .data-table th.sortable.desc::after {
            content: '↓';
            opacity: 1;
        }
        
        .data-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .data-table td.numeric {
            text-align: right;
            font-variant-numeric: tabular-nums;
        }
        
        .data-table tbody tr:hover {
            background-color: #f9fafb;
        }
        
        .data-table tbody tr:last-child td {
            border-bottom: none;
        }
        
        /* Mobile responsive */
        @media (max-width: 640px) {
            .data-table {
                font-size: 0.75rem;
            }
            
            .data-table th,
            .data-table td {
                padding: 0.5rem;
            }
        }
        
        /* Chart filters animation */
        .chart-filters {
            opacity: 0;
            transform: translateY(20px);
            animation: slideInUp 0.3s ease-out forwards;
            animation-delay: 0.05s;
        }
        
        /* Chart title */
        .chart-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin: 2rem 0 0 0;
            text-align: left;
            opacity: 0;
            transform: translateY(20px);
            animation: slideInUp 0.3s ease-out forwards;
            animation-delay: 0.35s;
        }
        
        /* Chart container animation */
        .chart-container {
            margin: 0;
            padding: 1em 0 0 0;
            opacity: 0;
            transform: scale(0.95);
            animation: fadeInScale 0.4s ease-out forwards;
            animation-delay: 0.4s;
        }
        
        /* Grouped Metrics Styles */
        .grouped-metrics {
            margin-bottom: 2rem;
            opacity: 0;
            transform: translateY(20px);
            animation: slideInUp 0.3s ease-out forwards;
            animation-delay: 0.05s;
        }
        
        .grouped-metrics h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .metrics-breakdown-table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        
        .metrics-breakdown-table th {
            background-color: #f9fafb;
            padding: 0.75rem 1rem;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
        }
        
        .metrics-breakdown-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: top;
        }
        
        .metrics-breakdown-table td.numeric {
            text-align: right;
            font-variant-numeric: tabular-nums;
            font-weight: 500;
        }
        
        .metrics-breakdown-table tbody tr:hover {
            background-color: #f9fafb;
        }
        
        .metrics-breakdown-table tbody tr:last-child td {
            border-bottom: none;
        }
        
        .metrics-breakdown-table tfoot {
            background-color: #f3f4f6;
            font-weight: 600;
        }
        
        .metrics-breakdown-table tfoot td {
            border-top: 2px solid #d1d5db;
            border-bottom: none;
        }
        
        .grouped-totals {
            display: flex;
            justify-content: space-around;
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f9fafb;
            border-radius: 0.5rem;
        }
        
        .grouped-total {
            text-align: center;
        }
        
        .grouped-total-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1f2937;
        }
        
        .grouped-total-label {
            font-size: 0.875rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
        
        .no-report {
            text-align: center;
            color: #6b7280;
            margin-top: 4rem;
        }
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            display: block;
        }
        .user-message {
            background-color: var(--message-surface, #e9e9e980);
            color: var(--text-primary, #0d0d0d);
            margin-left: auto;
            margin-right: 0;
            width: fit-content;
            max-width: 70%;
            border-radius: var(--radius-3xl, 1.5rem);
            padding-inline: calc(var(--spacing, 0.25rem) * 5);
            padding-block: calc(var(--spacing, 0.25rem) * 2.5);
            font-size: var(--text-base, 1rem);
            line-height: var(--text-base--line-height, 1.5);
            border: 0 solid;
            box-sizing: border-box;
        }
        .assistant-message {
            color: var(--text-primary);
            width: 100%;
            font-size: var(--text-base);
            line-height: var(--text-base--line-height);
            border-radius: var(--radius-lg);
            padding: var(--spacing);
            margin-bottom: calc(var(--spacing) * 2);
            overflow-wrap: break-word;
            border: 0 solid var(--border-light);
            box-sizing: border-box;
        }
        .assistant-message img {
            max-width: 100%;
            margin-top: 0.5rem;
        }
        .input-container {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
        }
        .button-row {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }
        .input {
            width: 100%;
            display: flex;
            cursor: text;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: clip;
            border-radius: 28px;
            background-color: var(--bg-primary);
            background-clip: padding-box;
            padding-inline: 1.2rem;
            padding-block: 1.2rem;
            border: 0 solid var(--border-light);
            font-size: var(--text-base);
            line-height: var(--text-base--line-height);
            color: var(--text-primary);
            min-height: 120px;
            resize: vertical;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            box-sizing: border-box;
            --tw-shadow: 0px 4px 4px 0px var(--tw-shadow-color, var(--shadow-color-1, #0000000a)), 0px 0px 1px 0px var(--tw-shadow-color, var(--shadow-color-2, #0000009e));
            box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
            transition: all var(--default-transition-duration) var(--default-transition-timing-function);
        }
        
        .input:focus {
            outline: none;
            border-color: var(--interactive-border-focus);
            --tw-shadow: 0px 4px 8px 0px var(--tw-shadow-color, var(--shadow-color-1, #0000000a)), 0px 0px 2px 0px var(--tw-shadow-color, var(--shadow-color-2, #0000009e));
            box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
        }
        .button {
            font: inherit;
            font-variation-settings: inherit;
            letter-spacing: inherit;
            opacity: 1;
            appearance: button;
            cursor: pointer;
            display: flex;
            height: auto;
            width: auto;
            padding: calc(var(--spacing) * 2) calc(var(--spacing) * 3);
            align-items: center;
            justify-content: center;
            border-radius: 3.40282e+38px;
            background-color: var(--black);
            color: #f1f1f1;
            border: 0 solid var(--border-light);
            box-sizing: border-box;
            margin: 0;
            position: absolute;
            bottom: calc(var(--spacing) * 8);
            right: calc(var(--spacing) * 6);
            transition-duration: var(--default-transition-duration);
            transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke;
            transition-timing-function: var(--default-transition-timing-function);
            -webkit-tap-highlight-color: transparent;
            -webkit-font-smoothing: antialiased;
        }
        .button:hover {
            background-color: #464646;
            color: var(--interactive-label-primary-hover);
        }
        .button:active {
            background-color: var(--interactive-bg-primary-press);
            color: var(--interactive-label-primary-press);
        }
        .button:disabled {
            background-color: var(--interactive-bg-primary-inactive);
            color: var(--interactive-label-primary-inactive);
            opacity: 0.5;
            cursor: not-allowed;
        }
        .undo-button {
            padding: 0.5rem 1rem;
            background-color: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 1rem;
            cursor: pointer;
        }
        .undo-button:hover {
            background-color: #e5e7eb;
        }
        .undo-button:disabled {
            background-color: #f9fafb;
            color: #9ca3af;
            cursor: not-allowed;
        }
        .mic-button {
            padding: 0.5rem;
            background-color: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 44px;
        }
        .mic-button:hover {
            background-color: #e5e7eb;
        }
        .mic-button.recording {
            background-color: #dc2626;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* Loading indicator */
        .loading-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            color: #6b7280;
            font-style: italic;
        }
        
        .loading-dots {
            display: flex;
            gap: 0.25rem;
        }
        
        .loading-dot {
            width: 13.5px;
            height: 13.5px;
            background-color: #222;
            border-radius: 50%;
            animation: loadingBounce 2s ease-in-out infinite both;
        }
        
        @keyframes loadingBounce {
            0%, 80%, 100% {
                transform: scale(0);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }
        .welcome {
            text-align: center;
            color: #6b7280;
            padding: 2rem;
        }
        .suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            margin-top: 1rem;
        }
        .suggestion {
            background-color: var(--message-surface, #e9e9e980);
            color: var(--text-primary, #0d0d0d);
            width: fit-content;
            border-radius: var(--radius-3xl, 1.5rem);
            padding-inline: calc(var(--spacing, 0.25rem) * 5);
            padding-block: calc(var(--spacing, 0.25rem) * 2.5);
            font-size: var(--text-base, 1rem);
            line-height: var(--text-base--line-height, 1.5);
            border: 0 solid;
            box-sizing: border-box;
            cursor: pointer;
        }
        .suggestion:hover {
            background-color: #e5e7eb;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* JSON display styles */
        .json-container {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 0.375rem;
            padding: 1rem;
            margin: 0.5rem 0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.875rem;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .json-content {
            white-space: pre-wrap;
            word-break: break-word;
            color: #495057;
        }
        
        .json-toggle {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 0.25rem;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            cursor: pointer;
            margin-bottom: 0.5rem;
        }
        
        .json-toggle:hover {
            background: #5a6268;
        }
        
        /* Markdown content styles */
        .markdown-content {
            line-height: 1.6;
        }
        
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            color: #1f2937;
        }
        
        .markdown-content h1 {
            font-size: 1.5em;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 0.3em;
        }
        
        .markdown-content h2 {
            font-size: 1.3em;
        }
        
        .markdown-content h3 {
            font-size: 1.1em;
        }
        
        .markdown-content p {
            margin: 0px !important;
        }
        
        
        .markdown-content ul, .markdown-content ol {
            margin: 0.8em 0;
            padding-left: 2em;
        }
        
        .markdown-content li {
            margin: 0.4em 0;
        }
        
        .markdown-content blockquote {
            border-left: 4px solid #e5e7eb;
            margin: 1em 0;
            padding-left: 1em;
            color: #6b7280;
            font-style: italic;
        }
        
        .markdown-content code {
            background: #f3f4f6;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .markdown-content pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 1em;
            overflow-x: auto;
            margin: 1em 0;
        }
        
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
        
        .markdown-content strong {
            font-weight: 600;
        }
        
        .markdown-content em {
            font-style: italic;
        }
        
        .markdown-content a {
            color: #222;
            text-decoration: none;
        }
        
        .markdown-content a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script>
        const { useState, useEffect, useRef } = React;
        const { createRoot } = ReactDOM;

        function App() {
            const [messages, setMessages] = useState([]);
            const [input, setInput] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [report, setReport] = useState(null);
            const [previousReport, setPreviousReport] = useState(null);
            const [threadId, setThreadId] = useState(null);
            const [selectedModel, setSelectedModel] = useState('deepseek');
            const [temperature, setTemperature] = useState(0.1);
            const [prefetchedData, setPrefetchedData] = useState(null);
            const [isPrefetching, setIsPrefetching] = useState(true);
            const [isRecording, setIsRecording] = useState(false);
            const [speechSupported, setSpeechSupported] = useState(false);
            const [isChatVisible, setIsChatVisible] = useState(true);
            const [expandedJsonMessages, setExpandedJsonMessages] = useState({});
            const messagesEndRef = useRef(null);
            const chartRef = useRef(null);
            const chartInstance = useRef(null);
            const mediaRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);

            // Auto-detect API URL based on current protocol (standard ports)
            const apiUrl = window.location.protocol + "//" + window.location.hostname;

            const scrollToBottom = () => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            };

            const scrollToLastAssistantMessage = () => {
                // Find the last assistant message element
                const messagesContainer = document.querySelector('.messages');
                const assistantMessages = messagesContainer?.querySelectorAll('.assistant-message');
                if (assistantMessages && assistantMessages.length > 0) {
                    const lastAssistantMessage = assistantMessages[assistantMessages.length - 1];
                    lastAssistantMessage.scrollIntoView({ behavior: "smooth", block: "start" });
                }
            };

            useEffect(() => {
                // Check if the last message is from assistant
                if (messages.length > 0) {
                    const lastMessage = messages[messages.length - 1];
                    if (lastMessage.role === 'assistant') {
                        // Small delay to ensure DOM is updated
                        setTimeout(() => {
                            scrollToLastAssistantMessage();
                        }, 100);
                    } else {
                        scrollToBottom();
                    }
                }
            }, [messages]);

            // Initialize audio recording and prefetch data on page load
            useEffect(() => {
                // Check for MediaRecorder support and secure context
                const isSecureContext = window.isSecureContext || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                const hasMediaRecorder = !!window.MediaRecorder;
                
                console.log('Audio recording check:', {
                    isSecureContext,
                    hasMediaRecorder,
                    hostname: window.location.hostname,
                    protocol: window.location.protocol
                });
                
                if (hasMediaRecorder && isSecureContext) {
                    setSpeechSupported(true);
                    console.log('Audio recording supported');
                } else {
                    console.log('Audio recording not supported:', {
                        reason: !hasMediaRecorder ? 'No MediaRecorder API' : 'Not secure context'
                    });
                    setSpeechSupported(false);
                }
                
                const prefetchData = async () => {
                    try {
                        console.log('🔄 Prefetching Huntflow data...');
                        const response = await fetch(`${apiUrl}/api/prefetch-data`);
                        const data = await response.json();
                        
                        console.log('✅ Prefetch complete:', data);
                        setPrefetchedData(data);
                        setIsPrefetching(false);
                    } catch (error) {
                        console.error('❌ Prefetch failed:', error);
                        setIsPrefetching(false);
                    }
                };
                
                prefetchData();
            }, []);

            // No longer generating fake data - using real API data only

            const generateChartData = (reportData) => {
                const chartConfig = reportData.chart;
                let data = {};

                // Use real data only
                const chartDataSource = chartConfig.real_data;
                if (chartDataSource && (chartDataSource.values || chartDataSource.points)) {
                    if (chartConfig.type === 'scatter') {
                        // For scatter plots, handle multiple data formats
                        let scatterData = chartDataSource.points || chartDataSource.values;
                        
                        // Convert array format [[x,y], [x,y]] to object format [{x,y}, {x,y}]
                        if (scatterData && Array.isArray(scatterData) && scatterData.length > 0) {
                            if (Array.isArray(scatterData[0])) {
                                // Format: [[x,y], [x,y]] -> [{x,y}, {x,y}]
                                scatterData = scatterData.map(point => ({
                                    x: point[0],
                                    y: point[1]
                                }));
                            }
                            // If already in {x,y} format, use as-is
                        } else {
                            // Fallback to random data
                            scatterData = Array.from({length: 20}, () => ({
                                x: Math.random() * 100,
                                y: Math.random() * 100
                            }));
                        }
                        
                        data = {
                            datasets: [{
                                label: chartConfig.y_label || chartConfig.y_axis_name || '',
                                data: scatterData,
                                backgroundColor: 'rgba(248, 179, 0, 0.8)'
                            }]
                        };
                    } else {
                        // For bar, line, histogram charts - need both labels and values
                        if (chartDataSource.labels && chartDataSource.values) {
                            data = {
                                labels: chartDataSource.labels,
                                datasets: [{
                                    label: '',
                                    data: chartDataSource.values,
                                    backgroundColor: chartConfig.type === 'line' ? 'rgba(248, 179, 0, 0.2)' : 'rgba(248, 179, 0, 0.8)',
                                    borderColor: 'rgba(248, 179, 0, 1)',
                                    borderWidth: 1,
                                    tension: chartConfig.type === 'line' ? 0.1 : undefined
                                }]
                            };
                        } else {
                            // Fall back to generated data if labels missing
                            data = null;
                        }
                    }
                }
                
                // If no valid data, show empty chart
                if (!data) {
                    data = {
                        labels: ['No Data'],
                        datasets: [{
                            label: '',
                            data: [0],
                            backgroundColor: 'rgba(156, 163, 175, 0.8)',
                            borderColor: 'rgba(156, 163, 175, 1)',
                            borderWidth: 1
                        }]
                    };
                }

                return data;
            };
            
            const renderGroupedMetrics = (reportData) => {
                const mainMetric = reportData.main_metric;
                const secondaryMetrics = reportData.secondary_metrics || [];
                
                // Always render traditional metric cards
                return React.createElement('div', { className: 'metrics-container', key: 'metrics' }, [
                    // Main metric card
                    React.createElement('div', { className: 'metric', key: 'main-metric' }, [
                        React.createElement('div', { className: 'metric-value', key: 'main-value' }, 
                            typeof (mainMetric.total_value || mainMetric.real_value || mainMetric.value || 0) === 'number' ? 
                                (mainMetric.total_value || mainMetric.real_value || mainMetric.value || 0).toLocaleString('ru-RU') : 
                                (mainMetric.total_value || mainMetric.real_value || mainMetric.value || 0)
                        ),
                        React.createElement('div', { className: 'metric-label', key: 'main-label' }, mainMetric.label)
                    ]),
                    // Secondary metric cards
                    ...secondaryMetrics.map((metric, index) => 
                        React.createElement('div', { className: 'metric', key: `secondary-${index}` }, [
                            React.createElement('div', { className: 'metric-value', key: `secondary-value-${index}` }, 
                                typeof (metric.total_value || metric.real_value || metric.value || 0) === 'number' ? 
                                    (metric.total_value || metric.real_value || metric.value || 0).toLocaleString('ru-RU') : 
                                    (metric.total_value || metric.real_value || metric.value || 0)
                            ),
                            React.createElement('div', { className: 'metric-label', key: `secondary-label-${index}` }, metric.label)
                        ])
                    )
                ]);
            };
            
            const renderTable = (tableData, container) => {
                if (!container) {
                    console.error('Container is null in renderTable');
                    return;
                }
                
                // Clear container
                container.innerHTML = '';
                
                // Create wrapper div for responsive scrolling
                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';
                
                // Create table element
                const table = document.createElement('table');
                table.className = 'data-table';
                
                // Generate table header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                tableData.columns.forEach(col => {
                    const th = document.createElement('th');
                    th.textContent = col.label;
                    th.className = col.sortable ? 'sortable' : '';
                    th.dataset.key = col.key;
                    
                    // Add sort indicator class
                    if (tableData.metadata?.sorted_by === col.key) {
                        th.className += ' ' + (tableData.metadata.sort_order || 'desc');
                    }
                    
                    if (col.sortable) {
                        th.addEventListener('click', () => sortTable(col.key, tableData, container));
                    }
                    
                    headerRow.appendChild(th);
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Generate table body
                const tbody = document.createElement('tbody');
                
                tableData.rows.forEach(row => {
                    const tr = document.createElement('tr');
                    
                    tableData.columns.forEach(col => {
                        const td = document.createElement('td');
                        const value = row[col.key];
                        
                        // Format based on column type
                        switch(col.type) {
                            case 'number':
                                td.textContent = value ? value.toLocaleString('ru-RU') : '0';
                                td.className = 'numeric';
                                break;
                            case 'percentage':
                                td.textContent = value ? `${value.toFixed(1)}%` : '0%';
                                td.className = 'numeric';
                                break;
                            default:
                                td.textContent = value || '';
                        }
                        
                        tr.appendChild(td);
                    });
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                wrapper.appendChild(table);
                container.appendChild(wrapper);
            };
            
            const sortTable = (key, tableData, container) => {
                // Toggle sort order
                const currentSort = tableData.metadata?.sorted_by;
                const currentOrder = tableData.metadata?.sort_order || 'desc';
                const newOrder = (currentSort === key && currentOrder === 'desc') ? 'asc' : 'desc';
                
                // Sort rows
                tableData.rows.sort((a, b) => {
                    const aVal = a[key];
                    const bVal = b[key];
                    
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return newOrder === 'desc' ? bVal - aVal : aVal - bVal;
                    }
                    
                    const aStr = String(aVal || '');
                    const bStr = String(bVal || '');
                    return newOrder === 'desc' ? bStr.localeCompare(aStr, 'ru') : aStr.localeCompare(bStr, 'ru');
                });
                
                // Update metadata
                if (!tableData.metadata) tableData.metadata = {};
                tableData.metadata.sorted_by = key;
                tableData.metadata.sort_order = newOrder;
                
                // Re-render table
                renderTable(tableData, container);
            };

            const createChart = (reportData) => {
                if (!chartRef.current || !reportData.chart) return;
                
                // Check if it's a table type
                if (reportData.chart.type === 'table') {
                    // Destroy any existing chart
                    if (chartInstance.current) {
                        chartInstance.current.destroy();
                        chartInstance.current = null;
                    }
                    
                    // Get the chart container (parent of canvas)
                    if (!chartRef.current || !chartRef.current.parentElement) {
                        console.error('Chart container not found');
                        return;
                    }
                    
                    const container = chartRef.current.parentElement;
                    
                    // Render table instead of chart
                    if (reportData.chart.real_data && container) {
                        renderTable(reportData.chart.real_data, container);
                    }
                    return;
                }
                
                // If switching from table to chart, ensure canvas exists
                if (!chartRef.current.getContext) {
                    // Canvas was replaced by table, recreate it
                    const container = chartRef.current.parentElement || chartRef.current;
                    container.innerHTML = '';
                    const canvas = document.createElement('canvas');
                    container.appendChild(canvas);
                    chartRef.current = canvas;
                }
                
                // Regular chart handling
                if (chartInstance.current) {
                    chartInstance.current.destroy();
                }

                const ctx = chartRef.current.getContext('2d');
                const chartData = generateChartData(reportData);
                const chartType = (reportData.chart.type === 'histogram' ? 'bar' : reportData.chart.type) || 'bar';

                chartInstance.current = new Chart(ctx, {
                    type: chartType,
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: false
                            },
                            legend: {
                                display: false
                            },
                            tooltip: chartType === 'scatter' ? {
                                callbacks: {
                                    label: function(context) {
                                        const point = context.raw;
                                        const recruiterName = point.label || 'Unknown';
                                        const xLabel = reportData.chart.x_label || 'X';
                                        const yLabel = reportData.chart.y_label || 'Y';
                                        return `${recruiterName}: ${xLabel}: ${point.x}, ${yLabel}: ${point.y}`;
                                    }
                                }
                            } : {}
                        },
                        scales: chartType !== 'scatter' ? {
                            x: {
                                title: {
                                    display: true,
                                    text: reportData.chart.x_label || reportData.chart.x_axis_name || 'X Axis'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: reportData.chart.y_label || reportData.chart.y_axis_name || 'Y Axis'
                                },
                                beginAtZero: true
                            }
                        } : {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: reportData.chart.x_label || reportData.chart.x_axis_name || 'X Axis'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: reportData.chart.y_label || reportData.chart.y_axis_name || 'Y Axis'
                                }
                            }
                        }
                    }
                });
            };

            useEffect(() => {
                if (report) {
                    // Small delay to ensure DOM is ready
                    setTimeout(() => {
                        createChart(report);
                    }, 100);
                }
            }, [report]);

            const handleSend = async () => {
                if (!input.trim() || isLoading) return;

                const userMessage = { role: 'user', content: input };
                const currentInput = input; // Store input before clearing
                setMessages(prev => [...prev, userMessage]);
                setInput('');
                setIsLoading(true);

                let reportData = null;
                let eventSource = null;
                let timeoutId = null;
                let lastAiMessage = null; // Track the last AI message in this conversation

                try {
                    // Try SSE streaming first, fallback to regular POST
                    const params = new URLSearchParams({
                        message: currentInput,
                        thread_id: threadId || '',
                        model: selectedModel,
                        temperature: temperature.toString()
                    });
                    
                    const eventSourceUrl = `${apiUrl}/chat-stream?${params}`;
                    console.log('Creating EventSource:', eventSourceUrl);
                    
                    eventSource = new EventSource(eventSourceUrl);
                    
                    // 90-second timeout for SSE connection
                    timeoutId = setTimeout(() => {
                        if (eventSource) {
                            eventSource.close();
                            throw new Error('SSE timeout after 90 seconds');
                        }
                    }, 90000);
                    
                    eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('SSE message received:', data.type, data);
                            
                            switch (data.type) {
                                case 'ai_message':
                                    // First AI response with tool calls - add as new message bubble
                                    if (data.content && data.content.trim() && data.content !== lastAiMessage) {
                                        lastAiMessage = data.content;
                                        console.log('Adding new AI message:', data.content);
                                        setMessages(prev => [...prev, { 
                                            role: 'assistant', 
                                            content: data.content 
                                        }]);
                                    }
                                    break;
                                    
                                case 'ai_message_chunk':
                                    // Streaming chunk - update the last assistant message
                                    if (data.content) {
                                        setMessages(prev => {
                                            const newMessages = [...prev];
                                            const lastMessage = newMessages[newMessages.length - 1];
                                            
                                            if (lastMessage && lastMessage.role === 'assistant') {
                                                // Append chunk to existing assistant message
                                                lastMessage.content += data.content;
                                            } else {
                                                // Create new assistant message if none exists
                                                newMessages.push({
                                                    role: 'assistant',
                                                    content: data.content
                                                });
                                            }
                                            
                                            return newMessages;
                                        });
                                    }
                                    break;
                                    
                                case 'tool_result':
                                    // Tool execution result with chart data
                                    reportData = data.chart_data;
                                    
                                    // Add JSON as a chat message (only if not already added)
                                    const jsonContent = JSON.stringify(reportData, null, 2);
                                    const lastMessage = messages[messages.length - 1];
                                    if (!lastMessage || !lastMessage.isJson || lastMessage.content !== jsonContent) {
                                        console.log('Adding JSON tool result to chat');
                                        setMessages(prev => [...prev, { 
                                            role: 'assistant', 
                                            content: jsonContent,
                                            isJson: true
                                        }]);
                                    }
                                    
                                    if (reportData && reportData.report_title && reportData.main_metric && reportData.chart) {
                                        console.log('Processing tool result for chart generation');
                                        const enrichedReport = {
                                            ...reportData,
                                            main_metric: {
                                                ...reportData.main_metric,
                                                value: reportData.main_metric.real_value ?? 0
                                            },
                                            secondary_metrics: reportData.secondary_metrics?.map(metric => ({
                                                ...metric,
                                                value: metric.real_value ?? 0
                                            })) || []
                                        };
                                        console.log('Setting report from SSE:', enrichedReport);
                                        setPreviousReport(report);
                                        setReport(enrichedReport);
                                    }
                                    break;
                                    
                                case 'ai_message_final':
                                    // Final AI response without tool calls - add as new message bubble
                                    if (data.content && data.content.trim() && data.content !== lastAiMessage) {
                                        lastAiMessage = data.content;
                                        console.log('Adding final AI message:', data.content);
                                        setMessages(prev => [...prev, { 
                                            role: 'assistant', 
                                            content: data.content 
                                        }]);
                                    }
                                    break;
                                    
                                case 'complete':
                                    // Streaming complete
                                    console.log('SSE streaming complete');
                                    if (data.thread_id && !threadId) {
                                        setThreadId(data.thread_id);
                                    }
                                    eventSource.close();
                                    if (timeoutId) clearTimeout(timeoutId);
                                    setIsLoading(false);
                                    break;
                                    
                                case 'error':
                                    // Error from server
                                    throw new Error(data.message || 'Ошибка сервера во время передачи данных');
                            }
                        } catch (parseError) {
                            console.error('Error parsing SSE data:', parseError, event.data);
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        console.error('SSE error:', error);
                        eventSource.close();
                        if (timeoutId) clearTimeout(timeoutId);
                        
                        setMessages(prev => [...prev, { 
                            role: 'assistant', 
                            content: '⚠️ Ошибка соединения во время передачи данных. Попробуйте снова.' 
                        }]);
                        setIsLoading(false);
                    };
                    
                } catch (error) {
                    if (eventSource) eventSource.close();
                    if (timeoutId) clearTimeout(timeoutId);
                    
                    let errorMessage;
                    if (error.message.includes('timeout')) {
                        errorMessage = '⏱️ Тайм-аут запроса через 90 секунд. Обработка LangGraph заняла слишком много времени. Попробуйте более простой вопрос или проверьте статус сервера.';
                    } else {
                        errorMessage = `⚠️ Ошибка: ${error.message || 'Что-то пошло не так. Попробуйте снова.'}`;
                    }
                    
                    setMessages(prev => [...prev, { 
                        role: 'assistant', 
                        content: errorMessage
                    }]);
                    setIsLoading(false);
                }
            };

            const handleSuggestion = (text) => {
                setInput(text);
                // Send the message immediately with the text
                if (!isLoading && text.trim()) {
                    setMessages(prev => [...prev, { role: 'user', content: text }]);
                    setInput('');
                    setIsLoading(true);
                    
                    // Same logic as handleSend but with the suggestion text
                    const params = new URLSearchParams({
                        message: text,
                        thread_id: threadId || '',
                        model: selectedModel,
                        temperature: temperature.toString()
                    });
                    
                    const eventSourceUrl = `${apiUrl}/chat-stream?${params}`;
                    console.log('Creating EventSource for suggestion:', eventSourceUrl);
                    
                    const eventSource = new EventSource(eventSourceUrl);
                    let reportData = null;
                    let lastAiMessage = '';
                    
                    const timeoutId = setTimeout(() => {
                        eventSource.close();
                        setMessages(prev => [...prev, { 
                            role: 'assistant', 
                            content: '⚠️ Тайм-аут запроса. Попробуйте снова.' 
                        }]);
                        setIsLoading(false);
                    }, 300000);

                    eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('SSE message received:', data.type, data);
                            
                            switch (data.type) {
                                case 'ai_message':
                                    if (data.content && data.content.trim() && data.content !== lastAiMessage) {
                                        lastAiMessage = data.content;
                                        console.log('Adding new AI message:', data.content);
                                        setMessages(prev => [...prev, { 
                                            role: 'assistant', 
                                            content: data.content 
                                        }]);
                                    }
                                    break;
                                    
                                case 'ai_message_chunk':
                                    if (data.content) {
                                        setMessages(prev => {
                                            const newMessages = [...prev];
                                            const lastMessage = newMessages[newMessages.length - 1];
                                            
                                            if (lastMessage && lastMessage.role === 'assistant') {
                                                lastMessage.content += data.content;
                                            } else {
                                                newMessages.push({
                                                    role: 'assistant',
                                                    content: data.content
                                                });
                                            }
                                            
                                            return newMessages;
                                        });
                                    }
                                    break;
                                    
                                case 'tool_result':
                                    reportData = data.chart_data;
                                    
                                    // Add JSON as a chat message (only if not already added)
                                    const jsonContent = JSON.stringify(reportData, null, 2);
                                    const lastMessage = messages[messages.length - 1];
                                    if (!lastMessage || !lastMessage.isJson || lastMessage.content !== jsonContent) {
                                        console.log('Adding JSON tool result to chat');
                                        setMessages(prev => [...prev, { 
                                            role: 'assistant', 
                                            content: jsonContent,
                                            isJson: true
                                        }]);
                                    }
                                    
                                    if (reportData && reportData.report_title && reportData.main_metric && reportData.chart) {
                                        console.log('Processing tool result for chart generation');
                                        const enrichedReport = {
                                            ...reportData,
                                            main_metric: {
                                                ...reportData.main_metric,
                                                value: reportData.main_metric.real_value ?? 0
                                            },
                                            secondary_metrics: reportData.secondary_metrics?.map(metric => ({
                                                ...metric,
                                                value: metric.real_value ?? 0
                                            })) || []
                                        };
                                        console.log('Setting report from SSE:', enrichedReport);
                                        setPreviousReport(report);
                                        setReport(enrichedReport);
                                    }
                                    break;
                                    
                                case 'chart_data':
                                    if (data.chart_data) {
                                        const enrichedReport = {
                                            ...data.chart_data,
                                            previous_report: previousReport
                                        };
                                        console.log('Setting report from SSE:', enrichedReport);
                                        setPreviousReport(report);
                                        setReport(enrichedReport);
                                    }
                                    break;
                                    
                                case 'ai_message_final':
                                    if (data.content && data.content.trim() && data.content !== lastAiMessage) {
                                        lastAiMessage = data.content;
                                        console.log('Adding final AI message:', data.content);
                                        setMessages(prev => [...prev, { 
                                            role: 'assistant', 
                                            content: data.content 
                                        }]);
                                    }
                                    break;
                                    
                                case 'complete':
                                    console.log('SSE streaming complete');
                                    if (data.thread_id && !threadId) {
                                        setThreadId(data.thread_id);
                                    }
                                    eventSource.close();
                                    if (timeoutId) clearTimeout(timeoutId);
                                    setIsLoading(false);
                                    break;
                                    
                                case 'error':
                                    throw new Error(data.message || 'Ошибка сервера во время передачи данных');
                            }
                        } catch (parseError) {
                            console.error('Error parsing SSE data:', parseError, event.data);
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        console.error('SSE error:', error);
                        eventSource.close();
                        if (timeoutId) clearTimeout(timeoutId);
                        
                        setMessages(prev => [...prev, { 
                            role: 'assistant', 
                            content: '⚠️ Ошибка соединения во время передачи данных. Попробуйте снова.' 
                        }]);
                        setIsLoading(false);
                    };
                }
            };

            const toggleChatPanel = () => {
                setIsChatVisible(!isChatVisible);
            };

            const handleUndo = () => {
                if (messages.length >= 2) {
                    // Remove last two messages (user question and AI response)
                    setMessages(prev => prev.slice(0, -2));
                    // Restore previous report
                    setReport(previousReport);
                    setPreviousReport(null);
                }
            };


            const toggleAudioRecording = async () => {
                if (!speechSupported) {
                    alert('Audio recording not supported. Try using Chrome/Edge on HTTPS or localhost.');
                    return;
                }

                if (isRecording) {
                    console.log('Stopping audio recording...');
                    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
                        mediaRecorderRef.current.stop();
                    }
                } else {
                    console.log('Starting audio recording...');
                    try {
                        // Request microphone access
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            audio: {
                                echoCancellation: true,
                                noiseSuppression: true,
                                autoGainControl: true
                            } 
                        });
                        
                        // Reset audio chunks
                        audioChunksRef.current = [];
                        
                        // Create MediaRecorder with appropriate mime type
                        let mimeType = 'audio/webm';
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = 'audio/wav';
                        }
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = 'audio/ogg';
                        }
                        
                        const mediaRecorder = new MediaRecorder(stream, { mimeType });
                        mediaRecorderRef.current = mediaRecorder;
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunksRef.current.push(event.data);
                            }
                        };
                        
                        mediaRecorder.onstop = async () => {
                            console.log('Audio recording stopped, processing...');
                            setIsRecording(false);
                            
                            // Stop all tracks to release microphone
                            stream.getTracks().forEach(track => track.stop());
                            
                            if (audioChunksRef.current.length > 0) {
                                // Create blob and send to transcription endpoint
                                const audioBlob = new Blob(audioChunksRef.current, { type: mimeType });
                                await transcribeAudio(audioBlob);
                            }
                        };
                        
                        mediaRecorder.start();
                        setIsRecording(true);
                        console.log('Audio recording started');
                        
                    } catch (error) {
                        console.error('Error starting audio recording:', error);
                        if (error.name === 'NotAllowedError') {
                            alert('Microphone access denied. Please allow microphone access to use voice input.');
                        } else if (error.name === 'NotFoundError') {
                            alert('No microphone found. Please check your microphone settings.');
                        } else {
                            alert(`Failed to start voice input: ${error.message}`);
                        }
                        setIsRecording(false);
                    }
                }
            };

            const transcribeAudio = async (audioBlob) => {
                try {
                    console.log('Sending audio for transcription...');
                    const formData = new FormData();
                    formData.append('audio', audioBlob, 'recording.webm');
                    
                    const response = await fetch(`${apiUrl}/transcribe`, {
                        method: 'POST',
                        body: formData,
                    });
                    
                    const result = await response.json();
                    
                    if (result.success && result.text) {
                        console.log('Transcription successful:', result.text);
                        setInput(result.text);
                    } else {
                        console.error('Transcription failed:', result.error);
                        alert(`Transcription failed: ${result.error || 'Unknown error'}`);
                    }
                } catch (error) {
                    console.error('Error during transcription:', error);
                    alert(`Failed to transcribe audio: ${error.message}`);
                }
            };

            const renderChartTitle = (reportData) => {
                if (!reportData || !reportData.chart || !reportData.chart.label) {
                    return null;
                }
                
                return React.createElement('h3', { 
                    className: 'chart-title', 
                    key: 'chart-title' 
                }, reportData.chart.label);
            };

            const renderChartFilters = (reportData) => {
                if (!reportData || !reportData.metrics_filter) {
                    return null;
                }
                
                const filters = reportData.metrics_filter;
                
                // Helper function to format filter values
                const formatFilterValue = (key, value) => {
                    switch (key) {
                        case 'period':
                            if (!value) return 'All time';
                            const periodMap = {
                                'today': 'Today',
                                'this week': 'This Week', 
                                '2 weeks': 'Last 2 Weeks',
                                '1 month': 'Last Month',
                                '3 month': 'Last 3 Months', 
                                '6 month': 'Last 6 months',
                                'year': 'Last Year'
                            };
                            return periodMap[value] || value;
                        case 'recruiters':
                            return value ? `Recruiter ID: ${value}` : 'All recruiters';
                        case 'vacancies':
                            if (!value) return 'All vacancies';
                            if (value === 'open') return 'Open vacancies';
                            if (value === 'closed') return 'Closed vacancies';  
                            return `Vacancy ID: ${value}`;
                        case 'sources':
                            return value ? `Source ID: ${value}` : 'All sources';
                        default:
                            return value || 'All';
                    }
                };
                
                return React.createElement('div', { className: 'chart-filters', key: 'chart-filters' }, [
                    React.createElement('div', { className: 'filters-grid', key: 'filters-grid' }, [
                        React.createElement('div', { className: 'filter-item', key: 'period' }, [
                            React.createElement('div', { 
                                className: `filter-value ${!filters.period ? 'empty' : ''}`, 
                                key: 'period-value' 
                            }, formatFilterValue('period', filters.period))
                        ]),
                        React.createElement('div', { className: 'filter-item', key: 'recruiter' }, [
                            React.createElement('div', { 
                                className: `filter-value ${!filters.recruiters ? 'empty' : ''}`, 
                                key: 'recruiter-value' 
                            }, formatFilterValue('recruiters', filters.recruiters))
                        ]),
                        React.createElement('div', { className: 'filter-item', key: 'vacancy' }, [
                            React.createElement('div', { 
                                className: `filter-value ${!filters.vacancies ? 'empty' : ''}`, 
                                key: 'vacancy-value' 
                            }, formatFilterValue('vacancies', filters.vacancies))
                        ]),
                        React.createElement('div', { className: 'filter-item', key: 'source' }, [
                            React.createElement('div', { 
                                className: `filter-value ${!filters.sources ? 'empty' : ''}`, 
                                key: 'source-value' 
                            }, formatFilterValue('sources', filters.sources))
                        ])
                    ])
                ]);
            };

            const renderMessage = (msg, index) => {
                const content = msg.content;
                
                // If this is a JSON message, format it specially
                if (msg.isJson) {
                    const messageId = `json-${index}`;
                    const isExpanded = expandedJsonMessages[messageId] || false;
                    
                    return React.createElement('div', {
                        className: 'json-container',
                        style: {
                            overflow: 'hidden',
                            width: 'fit-content',
                            backgroundColor: 'white',
                            padding: '0.5rem',
                            margin: '0'
                        }
                    }, [
                        React.createElement('button', {
                            key: 'toggle',
                            onClick: () => setExpandedJsonMessages(prev => ({
                                ...prev,
                                [messageId]: !isExpanded
                            })),
                            style: {
                                width: '100%',
                                border: 'none',
                                cursor: 'pointer',
                                textAlign: 'left',
                                fontFamily: "'Inter', system-ui, -apple-system, sans-serif",
                                fontSize: 'var(--text-base, 1rem)',
                                lineHeight: 'var(--text-base--line-height, 1.5)',
                                color: 'var(--text-primary, #0d0d0d)',
                                backgroundColor: 'white',
                                boxSizing: 'border-box'
                            }
                        }, `${isExpanded ? '▼' : '▶'} Исходник отчета`),
                        isExpanded ? React.createElement('pre', {
                            key: 'content',
                            style: {
                                margin: '0',
                                padding: '10px',
                                fontSize: '12px',
                                fontFamily: 'monospace',
                                overflow: 'auto',
                                maxHeight: '300px',
                                maxWidth: '320px'
                            }
                        }, content) : null
                    ]);
                }
                
                // Helper function to detect and format JSON
                const detectAndFormatJSON = (text) => {
                    const elements = [];
                    
                    // Regex to find JSON objects/arrays (basic detection)
                    const jsonRegex = /(\{[\s\S]*?\}|\[[\s\S]*?\])/g;
                    let lastIndex = 0;
                    let match;
                    
                    while ((match = jsonRegex.exec(text)) !== null) {
                        // Add text before JSON
                        if (match.index > lastIndex) {
                            elements.push(text.substring(lastIndex, match.index));
                        }
                        
                        // Try to parse as JSON
                        try {
                            const jsonObj = JSON.parse(match[1]);
                            const formattedJSON = JSON.stringify(jsonObj, null, 2);
                            
                            // Create collapsible JSON display
                            elements.push(React.createElement('div', {
                                key: `json-${match.index}`,
                                className: 'json-container'
                            }, [
                                React.createElement('button', {
                                    key: 'toggle',
                                    className: 'json-toggle',
                                    onClick: (e) => {
                                        const content = e.target.nextElementSibling;
                                        const isHidden = content.style.display === 'none';
                                        content.style.display = isHidden ? 'block' : 'none';
                                        e.target.textContent = isHidden ? 'Hide JSON' : 'Show JSON';
                                    }
                                }, 'Show JSON'),
                                React.createElement('div', {
                                    key: 'content',
                                    className: 'json-content',
                                    style: { display: 'none' }
                                }, formattedJSON)
                            ]));
                        } catch (e) {
                            // If not valid JSON, treat as regular text
                            elements.push(match[1]);
                        }
                        
                        lastIndex = jsonRegex.lastIndex;
                    }
                    
                    // Add remaining text
                    if (lastIndex < text.length) {
                        elements.push(text.substring(lastIndex));
                    }
                    
                    return elements.length > 1 ? elements : text;
                };
                
                // Handle markdown images like ![alt text](data:image/png;base64,...)
                if (content.includes('![') && content.includes('data:image/png;base64,')) {
                    // Split on image markdown pattern
                    const imageRegex = /!\[([^\]]*)\]\((data:image\/png;base64,[^)]+)\)/g;
                    let lastIndex = 0;
                    const elements = [];
                    let match;
                    
                    while ((match = imageRegex.exec(content)) !== null) {
                        // Add text before the image (with JSON detection)
                        if (match.index > lastIndex) {
                            const textPart = content.substring(lastIndex, match.index);
                            const processedText = detectAndFormatJSON(textPart);
                            if (Array.isArray(processedText)) {
                                elements.push(...processedText);
                            } else {
                                elements.push(processedText);
                            }
                        }
                        
                        // Add the image
                        elements.push(React.createElement('img', {
                            src: match[2],
                            alt: match[1] || 'Chart',
                            key: `img-${match.index}`,
                            style: { maxWidth: '100%', height: 'auto', margin: '10px 0' }
                        }));
                        
                        lastIndex = imageRegex.lastIndex;
                    }
                    
                    // Add remaining text after last image (with JSON detection)
                    if (lastIndex < content.length) {
                        const textPart = content.substring(lastIndex);
                        const processedText = detectAndFormatJSON(textPart);
                        if (Array.isArray(processedText)) {
                            elements.push(...processedText);
                        } else {
                            elements.push(processedText);
                        }
                    }
                    
                    return elements.length > 1 ? elements : content;
                }
                
                // Fallback: check for data URI without proper markdown
                if (content.includes('data:image/png;base64,')) {
                    const parts = content.split('data:image/png;base64,');
                    if (parts.length > 1) {
                        const base64Data = parts[1].split(/\s/)[0]; // Get base64 until whitespace
                        return [
                            detectAndFormatJSON(parts[0]),
                            React.createElement('img', { 
                                src: `data:image/png;base64,${base64Data}`, 
                                alt: 'Chart',
                                style: { maxWidth: '100%', height: 'auto', margin: '10px 0' }
                            }),
                            detectAndFormatJSON(parts[1].substring(base64Data.length))
                        ].flat();
                    }
                }
                
                // Default: render as markdown first, then check for JSON
                try {
                    // Use marked.js to render markdown to HTML
                    const htmlContent = marked.parse(content);
                    
                    // Create a div with dangerouslySetInnerHTML to render the markdown
                    return React.createElement('div', {
                        dangerouslySetInnerHTML: { __html: htmlContent },
                        className: 'markdown-content'
                    });
                } catch (e) {
                    // If markdown parsing fails, fall back to JSON detection
                    console.warn('Markdown parsing failed, falling back to plain text:', e);
                    return detectAndFormatJSON(content);
                }
            };

            return React.createElement('div', {}, [
                // Header
                React.createElement('div', { className: 'header', key: 'header' }),
                // Main container
                React.createElement('div', { className: 'container', key: 'main-container' }, [
                // Report Panel
                React.createElement('div', { 
                    className: `report-panel ${!isChatVisible ? 'full-width' : ''}`, 
                    key: 'report-panel' 
                }, [
                    // Chat toggle button
                    
                    report ? [
                        React.createElement('h1', { className: 'report-title', key: 'report-title' }, report.report_title),
                        // Render chart filters right after h1
                        renderChartFilters(report),
                        // Always render grouped metrics breakdown table
                        renderGroupedMetrics(report),
                        // Render chart title from chart.label
                        renderChartTitle(report),
                        React.createElement('div', { className: 'chart-container', key: 'chart-container' }, [
                            React.createElement('canvas', { ref: chartRef, key: 'chart' })
                        ])
                    ] : React.createElement('div', { className: 'no-report', key: 'no-report' }, 'Задайте вопрос для создания отчета')
                ]),
                // Chat Panel
                React.createElement('div', { 
                    className: `chat-panel ${!isChatVisible ? 'hidden' : ''}`, 
                    key: 'chat-panel' 
                }, [
                    React.createElement('div', { className: 'chat-container', key: 'chat' }, [
                    React.createElement('div', { className: 'messages', key: 'messages' }, [
                        messages.length === 0 && React.createElement('div', { className: 'welcome', key: 'welcome' }, [
                            isPrefetching ? 
                                React.createElement('div', { key: 'loading' }, [
                                    React.createElement('p', { key: 'loading-text' }, '🔄 Загрузка данных Huntflow...'),
                                    React.createElement('div', { 
                                        key: 'loading-spinner',
                                        style: { 
                                            animation: 'spin 1s linear infinite',
                                            fontSize: '24px',
                                            margin: '10px 0'
                                        }
                                    }, '⏳')
                                ]) :
                                [
                                    React.createElement('div', { className: 'suggestions', key: 'suggestions' }, [
                                        'Кто наш лучший рекрутер?',
                                        'Какое среднее время до найма?',
                                        'Какие источники лучше?',
                                        'Что там с воронкой?'
                                    ].map((text, i) => 
                                        React.createElement('button', {
                                            key: i,
                                            className: 'suggestion',
                                            onClick: () => handleSuggestion(text)
                                        }, text)
                                    ))
                                ]
                        ]),
                        ...messages.map((msg, index) => 
                            React.createElement('div', {
                                key: index,
                                className: `message ${msg.role}-message`
                            }, renderMessage(msg, index))
                        ),
                        // Loading indicator when waiting for assistant response
                        isLoading && React.createElement('div', { 
                            className: 'message assistant-message loading-indicator', 
                            key: 'loading' 
                        }, [
                            React.createElement('div', { className: 'loading-dots', key: 'loading-dots' }, [
                                React.createElement('div', { className: 'loading-dot', key: 'dot' })
                            ])
                        ]),
                        React.createElement('div', { ref: messagesEndRef, key: 'scroll-anchor' })
                    ]),
                    React.createElement('div', { className: 'input-container', key: 'input-container' }, [
                        // Simple textarea input
                        React.createElement('textarea', {
                            key: 'input',
                            className: 'input',
                            value: input,
                            onChange: (e) => setInput(e.target.value),
                            onKeyPress: (e) => {
                                if (e.key === 'Enter' && !e.shiftKey) {
                                    e.preventDefault();
                                    handleSend();
                                }
                            },
                            placeholder: 'Спросите о ваших данных по найму...',
                            disabled: isLoading
                        }),
                        // Button row under the textarea
                        React.createElement('div', {
                            key: 'button-row',
                            className: 'button-row'
                        }, [
                            React.createElement('button', {
                                key: 'send',
                                className: 'button',
                                onClick: handleSend,
                                disabled: isLoading || !input.trim()
                            }, 'Отправить')
                        ].filter(Boolean))
                    ])
                ])
                ])
                ])
            ]);
        }

        const root = createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>