<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huntflow Demo Bot</title>
    <style>
        body {
            margin: 0;
            font-family: system-ui, -apple-system, sans-serif;
            background-color: #f9fafb;
            height: 100vh;
        }
        #root {
            height: 100%;
        }
        .container {
            margin: 0;
            padding: 0;
            height: 100%;
            display: flex;
            flex-direction: row;
        }
        .report-panel {
            width: 65%;
            background: white;
            border-right: 1px solid #e5e7eb;
            padding: 2rem;
            overflow-y: auto;
        }
        .chat-panel {
            width: 35%;
            background: #f9fafb;
            display: flex;
            flex-direction: column;
            padding: 0;
        }
        .title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 1rem;
        }
        .chat-container {
            flex: 1;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            height: 1vh;
        }
        .report-title {
            font-size: 1.75rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 2rem;
            text-align: center;
        }
        .metrics-container {
            display: flex;
            justify-content: space-around;
            margin-bottom: 2rem;
        }
        .metric {
            text-align: center;
        }
        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #3b82f6;
            margin-bottom: 0.5rem;
        }
        .metric-label {
            font-size: 0.875rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .chart-container {
            margin-top: 2rem;
            height: 400px;
        }
        .no-report {
            text-align: center;
            color: #6b7280;
            margin-top: 4rem;
        }
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
        }
        .user-message {
            background-color: #3b82f6;
            color: white;
            margin-left: 2rem;
        }
        .assistant-message {
            background-color: #f3f4f6;
            color: #1f2937;
            margin-right: 2rem;
        }
        .assistant-message img {
            max-width: 100%;
            margin-top: 0.5rem;
        }
        .input-container {
            display: flex;
            gap: 0.5rem;
            padding: 1rem;
            border-top: 1px solid #e5e7eb;
        }
        .input {
            flex: 1;
            padding: 0.5rem 1rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 1rem;
        }
        .button {
            padding: 0.5rem 1rem;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-size: 1rem;
            cursor: pointer;
        }
        .button:hover {
            background-color: #2563eb;
        }
        .button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        .mic-button {
            padding: 0.5rem;
            background-color: #6b7280;
            color: white;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 44px;
        }
        .mic-button:hover {
            background-color: #4b5563;
        }
        .mic-button.recording {
            background-color: #dc2626;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .welcome {
            text-align: center;
            color: #6b7280;
            padding: 2rem;
        }
        .suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            margin-top: 1rem;
        }
        .suggestion {
            padding: 0.5rem 1rem;
            background-color: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.875rem;
        }
        .suggestion:hover {
            background-color: #e5e7eb;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script>
        const { useState, useEffect, useRef } = React;
        const { createRoot } = ReactDOM;

        function App() {
            const [messages, setMessages] = useState([]);
            const [input, setInput] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [report, setReport] = useState(null);
            const [threadId, setThreadId] = useState(null);
            const [selectedModel, setSelectedModel] = useState('deepseek');
            const [temperature, setTemperature] = useState(0.1);
            const [prefetchedData, setPrefetchedData] = useState(null);
            const [isPrefetching, setIsPrefetching] = useState(true);
            const [isRecording, setIsRecording] = useState(false);
            const [speechSupported, setSpeechSupported] = useState(false);
            const messagesEndRef = useRef(null);
            const chartRef = useRef(null);
            const chartInstance = useRef(null);
            const recognitionRef = useRef(null);

            // Auto-detect API URL based on current protocol
            const isHttps = window.location.protocol === 'https:';
            const apiPort = isHttps ? '8443' : '8000';
            const apiUrl = window.location.protocol + "//" + window.location.hostname + ":" + apiPort;

            const scrollToBottom = () => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            };

            useEffect(() => {
                scrollToBottom();
            }, [messages]);

            // Initialize speech recognition and prefetch data on page load
            useEffect(() => {
                // Check for speech recognition support and HTTPS/localhost
                const isSecureContext = window.isSecureContext || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                console.log('Speech recognition check:', {
                    isSecureContext,
                    hasSpeechRecognition: !!SpeechRecognition,
                    hostname: window.location.hostname,
                    protocol: window.location.protocol
                });
                
                if (SpeechRecognition && isSecureContext) {
                    try {
                        const recognition = new SpeechRecognition();
                        recognition.continuous = false;
                        recognition.interimResults = false;
                        recognition.maxAlternatives = 1;
                        recognition.lang = 'ru-RU'; // Russian language for better recognition
                        
                        // Add some additional language fallbacks
                        if (navigator.language.startsWith('en')) {
                            recognition.lang = 'en-US';
                        }
                        
                        recognition.onstart = () => {
                            console.log('Speech recognition started');
                            setIsRecording(true);
                        };
                        
                        recognition.onresult = (event) => {
                            const transcript = event.results[0][0].transcript;
                            console.log('Speech recognition result:', transcript);
                            setInput(transcript);
                            setIsRecording(false);
                        };
                        
                        recognition.onerror = (event) => {
                            console.error('Speech recognition error:', event.error);
                            if (event.error === 'not-allowed') {
                                alert('Microphone access denied. Please allow microphone access to use voice input.');
                            } else if (event.error === 'network') {
                                alert('Network error with speech recognition. This often happens with the browser\'s built-in speech service. Try:\n\n1. Check internet connection\n2. Try again in a few seconds\n3. Use Chrome/Edge browser\n4. Access via HTTPS for better compatibility');
                            } else if (event.error === 'no-speech') {
                                alert('No speech was detected. Please try speaking closer to the microphone.');
                            } else if (event.error === 'audio-capture') {
                                alert('Microphone not available. Please check your microphone settings.');
                            } else if (event.error === 'service-not-allowed') {
                                alert('Speech recognition service blocked. Try accessing via HTTPS.');
                            } else {
                                alert(`Speech recognition error: ${event.error}\n\nTry refreshing the page or using a different browser.`);
                            }
                            setIsRecording(false);
                        };
                        
                        recognition.onend = () => {
                            console.log('Speech recognition ended');
                            setIsRecording(false);
                        };
                        
                        recognitionRef.current = recognition;
                        setSpeechSupported(true);
                        console.log('Speech recognition initialized successfully');
                    } catch (error) {
                        console.error('Failed to initialize speech recognition:', error);
                        setSpeechSupported(false);
                    }
                } else {
                    console.log('Speech recognition not supported:', {
                        reason: !SpeechRecognition ? 'No SpeechRecognition API' : 'Not secure context'
                    });
                    setSpeechSupported(false);
                }
                
                const prefetchData = async () => {
                    try {
                        console.log('üîÑ Prefetching Huntflow data...');
                        const response = await fetch(`${apiUrl}/api/prefetch-data`);
                        const data = await response.json();
                        
                        console.log('‚úÖ Prefetch complete:', data);
                        setPrefetchedData(data);
                        setIsPrefetching(false);
                    } catch (error) {
                        console.error('‚ùå Prefetch failed:', error);
                        setIsPrefetching(false);
                    }
                };
                
                prefetchData();
            }, []);

            // No longer generating fake data - using real API data only

            const generateChartData = (reportData) => {
                const chartConfig = reportData.chart;
                let data = {};

                // Use real data only
                const chartDataSource = chartConfig.real_data;
                if (chartDataSource && (chartDataSource.values || chartDataSource.points)) {
                    if (chartConfig.type === 'scatter') {
                        // For scatter plots, handle multiple data formats
                        let scatterData = chartDataSource.points || chartDataSource.values;
                        
                        // Convert array format [[x,y], [x,y]] to object format [{x,y}, {x,y}]
                        if (scatterData && Array.isArray(scatterData) && scatterData.length > 0) {
                            if (Array.isArray(scatterData[0])) {
                                // Format: [[x,y], [x,y]] -> [{x,y}, {x,y}]
                                scatterData = scatterData.map(point => ({
                                    x: point[0],
                                    y: point[1]
                                }));
                            }
                            // If already in {x,y} format, use as-is
                        } else {
                            // Fallback to random data
                            scatterData = Array.from({length: 20}, () => ({
                                x: Math.random() * 100,
                                y: Math.random() * 100
                            }));
                        }
                        
                        data = {
                            datasets: [{
                                label: chartConfig.y_label || chartConfig.y_axis_name || 'Data Points',
                                data: scatterData,
                                backgroundColor: 'rgba(59, 130, 246, 0.8)'
                            }]
                        };
                    } else {
                        // For bar, line, histogram charts - need both labels and values
                        if (chartDataSource.labels && chartDataSource.values) {
                            data = {
                                labels: chartDataSource.labels,
                                datasets: [{
                                    label: chartConfig.y_label || chartConfig.y_axis_name || 'Count',
                                    data: chartDataSource.values,
                                    backgroundColor: chartConfig.type === 'line' ? 'rgba(59, 130, 246, 0.2)' : 'rgba(59, 130, 246, 0.8)',
                                    borderColor: 'rgba(59, 130, 246, 1)',
                                    borderWidth: 1,
                                    tension: chartConfig.type === 'line' ? 0.1 : undefined
                                }]
                            };
                        } else {
                            // Fall back to generated data if labels missing
                            data = null;
                        }
                    }
                }
                
                // If no valid data, show empty chart
                if (!data) {
                    data = {
                        labels: ['No Data'],
                        datasets: [{
                            label: chartConfig.y_label || chartConfig.y_axis_name || 'Count',
                            data: [0],
                            backgroundColor: 'rgba(156, 163, 175, 0.8)',
                            borderColor: 'rgba(156, 163, 175, 1)',
                            borderWidth: 1
                        }]
                    };
                }

                return data;
            };

            const createChart = (reportData) => {
                if (chartInstance.current) {
                    chartInstance.current.destroy();
                }

                if (!chartRef.current || !reportData.chart) return;

                const ctx = chartRef.current.getContext('2d');
                const chartData = generateChartData(reportData);
                const chartType = (reportData.chart.type === 'histogram' ? 'bar' : reportData.chart.type) || 'bar';

                chartInstance.current = new Chart(ctx, {
                    type: chartType,
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: reportData.chart.label || reportData.chart.graph_description || 'Chart'
                            },
                            legend: {
                                display: chartType !== 'scatter'
                            }
                        },
                        scales: chartType !== 'scatter' ? {
                            x: {
                                title: {
                                    display: true,
                                    text: reportData.chart.x_label || reportData.chart.x_axis_name || 'X Axis'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: reportData.chart.y_label || reportData.chart.y_axis_name || 'Y Axis'
                                },
                                beginAtZero: true
                            }
                        } : {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: reportData.chart.x_label || reportData.chart.x_axis_name || 'X Axis'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: reportData.chart.y_label || reportData.chart.y_axis_name || 'Y Axis'
                                }
                            }
                        }
                    }
                });
            };

            useEffect(() => {
                if (report) {
                    createChart(report);
                }
            }, [report]);

            const handleSend = async () => {
                if (!input.trim() || isLoading) return;

                const userMessage = { role: 'user', content: input };
                setMessages(prev => [...prev, userMessage]);
                setInput('');
                setIsLoading(true);

                try {
                    const response = await fetch(`${apiUrl}/chat`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            message: input,
                            thread_id: threadId,
                            model: selectedModel,
                            use_real_data: true,
                            messages: messages,
                            temperature: temperature
                        }),
                    });

                    const data = await response.json();
                    
                    // Store thread_id for future requests
                    if (data.thread_id && !threadId) {
                        setThreadId(data.thread_id);
                    }
                    
                    setMessages(prev => [...prev, { 
                        role: 'assistant', 
                        content: data.response 
                    }]);

                    // Try to parse JSON response for report generation
                    try {
                        console.log('Trying to parse response:', data.response.substring(0, 200));
                        
                        // Extract JSON from markdown code blocks if present
                        let jsonString = data.response;
                        const jsonMatch = data.response.match(/```json\s*([\s\S]*?)\s*```/);
                        if (jsonMatch) {
                            jsonString = jsonMatch[1];
                            console.log('Extracted JSON from code blocks:', jsonString.substring(0, 100));
                        }
                        
                        const reportData = JSON.parse(jsonString);
                        console.log('Parsed JSON successfully:', reportData);
                        console.log('Has report_title:', !!reportData.report_title);
                        console.log('Has main_metric:', !!reportData.main_metric);
                        console.log('Has chart:', !!reportData.chart);
                        
                        if (reportData.report_title && reportData.main_metric && reportData.chart) {
                            console.log('All conditions met, generating report');
                            // Use real data only - no demo fallbacks
                            const enrichedReport = {
                                ...reportData,
                                main_metric: {
                                    ...reportData.main_metric,
                                    value: reportData.main_metric.real_value ?? 0
                                },
                                secondary_metrics: reportData.secondary_metrics?.map(metric => ({
                                    ...metric,
                                    value: metric.real_value ?? 0
                                })) || []
                            };
                            console.log('Setting report:', enrichedReport);
                            setReport(enrichedReport);
                        } else {
                            console.log('Conditions not met for report generation');
                        }
                    } catch (jsonError) {
                        // Not a JSON response, no report to generate
                        console.log('Response is not JSON, skipping report generation. Error:', jsonError);
                    }
                } catch (error) {
                    setMessages(prev => [...prev, { 
                        role: 'assistant', 
                        content: '‚ö†Ô∏è Error connecting to the server. Please check if the backend is running.' 
                    }]);
                } finally {
                    setIsLoading(false);
                }
            };

            const handleSuggestion = (text) => {
                setInput(text);
            };

            const toggleSpeechRecognition = () => {
                if (!speechSupported || !recognitionRef.current) {
                    const reasons = [];
                    if (!speechSupported) reasons.push('Speech recognition not supported');
                    if (!recognitionRef.current) reasons.push('Recognition not initialized');
                    
                    alert(`Voice input unavailable: ${reasons.join(', ')}. Try Chrome/Edge on HTTPS or localhost.`);
                    return;
                }

                if (isRecording) {
                    console.log('Stopping speech recognition...');
                    recognitionRef.current.stop();
                } else {
                    console.log('Starting speech recognition...');
                    try {
                        recognitionRef.current.start();
                    } catch (error) {
                        console.error('Error starting speech recognition:', error);
                        if (error.name === 'InvalidStateError') {
                            alert('Speech recognition is already active. Please wait a moment and try again.');
                        } else {
                            alert(`Failed to start voice input: ${error.message}`);
                        }
                        setIsRecording(false);
                    }
                }
            };

            const renderMessage = (msg) => {
                // Handle markdown images like ![alt text](data:image/png;base64,...)
                if (msg.content.includes('![') && msg.content.includes('data:image/png;base64,')) {
                    // Split on image markdown pattern
                    const imageRegex = /!\[([^\]]*)\]\((data:image\/png;base64,[^)]+)\)/g;
                    let lastIndex = 0;
                    const elements = [];
                    let match;
                    
                    while ((match = imageRegex.exec(msg.content)) !== null) {
                        // Add text before the image
                        if (match.index > lastIndex) {
                            elements.push(msg.content.substring(lastIndex, match.index));
                        }
                        
                        // Add the image
                        elements.push(React.createElement('img', {
                            src: match[2],
                            alt: match[1] || 'Chart',
                            key: `img-${match.index}`,
                            style: { maxWidth: '100%', height: 'auto', margin: '10px 0' }
                        }));
                        
                        lastIndex = imageRegex.lastIndex;
                    }
                    
                    // Add remaining text after last image
                    if (lastIndex < msg.content.length) {
                        elements.push(msg.content.substring(lastIndex));
                    }
                    
                    return elements.length > 1 ? elements : msg.content;
                }
                
                // Fallback: check for data URI without proper markdown
                if (msg.content.includes('data:image/png;base64,')) {
                    const parts = msg.content.split('data:image/png;base64,');
                    if (parts.length > 1) {
                        const base64Data = parts[1].split(/\s/)[0]; // Get base64 until whitespace
                        return [
                            parts[0],
                            React.createElement('img', { 
                                src: `data:image/png;base64,${base64Data}`, 
                                alt: 'Chart',
                                style: { maxWidth: '100%', height: 'auto', margin: '10px 0' }
                            }),
                            parts[1].substring(base64Data.length)
                        ];
                    }
                }
                
                return msg.content;
            };

            return React.createElement('div', { className: 'container' }, [
                // Report Panel
                React.createElement('div', { className: 'report-panel', key: 'report-panel' }, [
                    report ? [
                        React.createElement('h1', { className: 'report-title', key: 'report-title' }, report.report_title),
                        React.createElement('div', { className: 'metrics-container', key: 'metrics' }, [
                            React.createElement('div', { className: 'metric', key: 'main-metric' }, [
                                React.createElement('div', { className: 'metric-value', key: 'main-value' }, report.main_metric.value),
                                React.createElement('div', { className: 'metric-label', key: 'main-label' }, report.main_metric.label)
                            ]),
                            ...report.secondary_metrics.map((metric, index) => 
                                React.createElement('div', { className: 'metric', key: `secondary-${index}` }, [
                                    React.createElement('div', { className: 'metric-value', key: `secondary-value-${index}` }, metric.value),
                                    React.createElement('div', { className: 'metric-label', key: `secondary-label-${index}` }, metric.label)
                                ])
                            )
                        ]),
                        React.createElement('div', { className: 'chart-container', key: 'chart-container' }, [
                            React.createElement('canvas', { ref: chartRef, key: 'chart' })
                        ])
                    ] : React.createElement('div', { className: 'no-report', key: 'no-report' }, 'Ask a question to generate a report')
                ]),
                // Chat Panel
                React.createElement('div', { className: 'chat-panel', key: 'chat-panel' }, [
                    React.createElement('div', { className: 'chat-container', key: 'chat' }, [
                    React.createElement('div', { className: 'messages', key: 'messages' }, [
                        messages.length === 0 && React.createElement('div', { className: 'welcome', key: 'welcome' }, [
                            isPrefetching ? 
                                React.createElement('div', { key: 'loading' }, [
                                    React.createElement('p', { key: 'loading-text' }, 'üîÑ Loading Huntflow data...'),
                                    React.createElement('div', { 
                                        key: 'loading-spinner',
                                        style: { 
                                            animation: 'spin 1s linear infinite',
                                            fontSize: '24px',
                                            margin: '10px 0'
                                        }
                                    }, '‚è≥')
                                ]) :
                                [
                                    React.createElement('p', { key: 'welcome-text' }, '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –Ø –ø–æ–º–æ–≥—É –≤–∞–º –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ—Ü–µ—Å—Å—ã –Ω–∞–π–º–∞ –≤ Huntflow.'),
                                    React.createElement('div', { className: 'suggestions', key: 'suggestions' }, [
                                        '–ö—Ç–æ –Ω–∞—à –ª—É—á—à–∏–π —Ä–µ–∫—Ä—É—Ç–µ—Ä?',
                                        '–ö–∞–∫–æ–µ —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –¥–æ –Ω–∞–π–º–∞?',
                                        '–ö–∞–∫–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –ª—É—á—à–µ?',
                                        '–ß—Ç–æ —Ç–∞–º —Å –≤–æ—Ä–æ–Ω–∫–æ–π?'
                                    ].map((text, i) => 
                                        React.createElement('button', {
                                            key: i,
                                            className: 'suggestion',
                                            onClick: () => handleSuggestion(text)
                                        }, text)
                                    ))
                                ]
                        ]),
                        ...messages.map((msg, index) => 
                            React.createElement('div', {
                                key: index,
                                className: `message ${msg.role}-message`
                            }, renderMessage(msg))
                        ),
                        isLoading && React.createElement('div', {
                            key: 'loading',
                            className: 'message assistant-message'
                        }, 'Thinking...'),
                        React.createElement('div', { ref: messagesEndRef, key: 'scroll-anchor' })
                    ]),
                    React.createElement('div', { className: 'input-container', key: 'input-container' }, [
                        React.createElement('input', {
                            key: 'input',
                            type: 'text',
                            className: 'input',
                            value: input,
                            onChange: (e) => setInput(e.target.value),
                            onKeyPress: (e) => e.key === 'Enter' && handleSend(),
                            placeholder: 'Ask about Huntflow data...',
                            disabled: isLoading
                        }),
                        speechSupported && React.createElement('button', {
                            key: 'mic',
                            className: `mic-button ${isRecording ? 'recording' : ''}`,
                            onClick: toggleSpeechRecognition,
                            disabled: isLoading,
                            title: isRecording ? 'Stop recording' : 'Start voice input'
                        }, isRecording ? '‚èπÔ∏è' : 'üé§'),
                        React.createElement('button', {
                            key: 'send',
                            className: 'button',
                            onClick: handleSend,
                            disabled: isLoading || !input.trim()
                        }, 'Send')
                    ])
                ])
                ])
            ]);
        }

        const root = createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>